00000000                                     1  * Jason F. Smith    CSE 312     SS# 4588
00000000                                     2  
00000000                                     3  *	ENTER YOUR TITLE BLOCK HERE
00000000                                     4  
00000000                                     5  
00000000                                     6  ************************************************************************
00000000                                     7  * Prefix file to CSE 312 homework 9 program.
00000000                                     8  * V3.1  9Nov.98
00000000                                     9  *****************************************************************************
00000000                                    10  * System (VECTOR TABLE) initialization parameters:
00000000                                    11  		org	0		; initial system stack pointer and
00000000  00010000 00001000                 12  		dc.l	$10000,$1000	; initial program counter
00000010                                    13  		org	$10
00000010  00000E00                          14  		dc.l	$e00		; initialize "illegal" inst. vector
00000070                                    15  		org	$70
00000070  00000800                          16  		dc.l	$800		; init. level 4 auto interrupt vector
00000080                                    17  		org	$80
00000080  00000400                          18  		dc.l	init_duart	; TRAP#0: initialize serial port driver
00000084  000004FE                          19  		dc.l	key_ck_a	; TRAP#1: check keyboard from Port A
00000088  000004CC                          20  		dc.l	gchar_a		; TRAP#2: get character from Port A
0000008C  00000468                          21  		dc.l	pchar_a		; TRAP#3: put character to Port A
00000090                                    22  		ds.l	1		; TRAP#4: not defined yet
00000094  00000486                          23  		dc.l	gcha_bs		; TRAP#5: empty a character from Port B
00000098  0000049A                          24  		dc.l	gchar_b		; TRAP#6: get character from Port B
0000009C  0000044A                          25  		dc.l	pchar_b		; TRAP#7: put character to Port B
000000A0                                    26  *---------------------------------------------------------------------
00000E00                                    27  		org	$e00		; illegal instruction start here
00000E00  4E71                              28  goon:		nop			; illegal instruction definition:
00000E02  60FC                              29  		bra	goon		; //////// CPU idling ////////
00000E04                                    30  *************************************************************************
00000E04                                    31  * M68681 Dual Serial Port constants
00000E04  =00020000                         32  duart:		equ	$00020000	; M68681 Dual Serial Port base addr.
00000E04  =00000001                         33  mr1a:		equ	1		; mode register 1
00000E04  =00000001                         34  mr2a		equ	1		; mode register 2
00000E04  =00000003                         35  sra:		equ	3		; status register
00000E04  =00000003                         36  csra:		equ	3		; clock select register
00000E04  =00000005                         37  cra:		equ	5		; command register
00000E04  =00000007                         38  rba:		equ	7		; rx buffer register, serial in
00000E04  =00000007                         39  tba:		equ	7		; tx buffer register, data out
00000E04  =00000009                         40  ipcr:		equ	9		; input port change register
00000E04  =00000009                         41  acr:		equ	9		; auxiliary control register
00000E04  =0000000B                         42  isr:		equ	11		; interrupt status register
00000E04  =0000000B                         43  imr:		equ	11		; interrupt mask register
00000E04  =00000011                         44  mr1b:		equ	17		;  register for port B
00000E04  =00000011                         45  mr2b:		equ	17		;  register for port B
00000E04  =00000013                         46  srb:		equ	19		;  register for port B
00000E04  =00000013                         47  csrb:		equ	19		;  register for port B
00000E04  =00000015                         48  crb:		equ	21		;  register for port B
00000E04  =00000017                         49  rbb:		equ	23		;  register for port B
00000E04  =00000017                         50  tbb:		equ	23		;  register for port B
00000E04  =00000019                         51  ivr:		equ	25		; ivterrupt vector register
00000E04  =00000002                         52  txrdy:		equ	2
00000E04  =00000000                         53  rxrdy:		equ	0
00000E04                                    54  *-------------------------------------------------------------------
00000E04                                    55  * Serial I/O routines
00000E04                                    56  *-------------------------------------------------------------------
00000E04                                    57  * name: 	init_duart
00000E04                                    58  * function:	M68681 Dual Serial Port initialize subroutine
00000E04                                    59  * input: 	<none>
00000E04                                    60  * output:	<none>
00000E04                                    61  * registers:	A0
00000E04                                    62  *
00000400                                    63  		org	$400		; DUART init. program
00000400  41F9 00020000                     64  init_duart:	lea	duart,a0
00000406  117C 0080 0009                    65  		move.b	#$80,acr(a0)	; select baud-rate set 1
0000040C  117C 00CC 0003                    66  		move.b	#$cc,csra(a0)	; set both rx and tx speed to 19.2k
00000412  117C 00CC 0013                    67  		move.b	#$cc,csrb(a0)	; set both rx and tx speed to 19.2k
00000418  117C 0002 0001                    68  		move.b	#$02,mr1a(a0)	; set port A to 7 bit, even parity,
0000041E                                    69  *                                       ;    1 stop bit, rxrdy enabled.
0000041E  117C 0002 0011                    70  		move.b	#$02,mr1b(a0)	; set port B to 7 bit, even parity,
00000424                                    71  *                                       ;    1 stop bit, rxrdy enabled.
00000424  117C 0007 0001                    72  		move.b	#$07,mr2a(a0)	; select normal operation mode, disable
0000042A                                    73  *					; txrtx, txcts, 1 stop bit
0000042A  117C 0007 0011                    74  		move.b	#$07,mr2b(a0)	; select normal operation mode, disable
00000430                                    75  *					; txrtx, txcts, 1 stop bit
00000430  117C 0005 0005                    76  		move.b	#$05,cra(a0)	; enable port A tx and rx
00000436  117C 0005 0015                    77  		move.b	#$05,crb(a0)	; enable port B tx and rx
0000043C  117C 0020 000B                    78  		move.b	#$20,imr(a0)	; enable rxrdy B interrupt and
00000442                                    79  *					;      disable other interrupt
00000442  117C 001C 0019                    80  		move.b	#28,ivr(a0)	; set interrupt vector same as auto vec.
00000448  4E73                              81  		rte
0000044A                                    82  ********************************************************************
0000044A                                    83  * name: 	pchar_b
0000044A                                    84  * function:	transmit a byte of data to serial port B
0000044A                                    85  * input: 	D0, data to send
0000044A                                    86  * output:	<none>
0000044A                                    87  * registers:	A0,D1
0000044A                                    88  *
0000044A  48E7 4080                         89  pchar_b:	movem.l	d1/a0,-(sp)	; transmit a byte data in d0
0000044E  41F9 00020000                     90  		lea	duart,a0	;    to the serial port B.
00000454  1228 0013                         91  opoll_b:	move.b	srb(a0),d1
00000458  0801 0002                         92  		btst	#txrdy,d1
0000045C  67F6                              93  		beq	opoll_b
0000045E  1140 0017                         94  		move.b	d0,tbb(a0)
00000462  4CDF 0102                         95  		movem.l	(sp)+,d1/a0
00000466  4E73                              96  		rte
00000468                                    97  ********************************************************************
00000468                                    98  * name: 	pchar_a
00000468                                    99  * function:	transmit a byte of data to serial port A
00000468                                   100  * input: 	D0, data to send
00000468                                   101  * output:	<none>
00000468                                   102  * registers:	A0,D1
00000468                                   103  *
00000468  48E7 4080                        104  pchar_a:	movem.l	d1/a0,-(sp)	; transmit a byte data in d0
0000046C  41F9 00020000                    105  		lea	duart,a0	;    to the serial port A.
00000472  1228 0003                        106  opoll_a:	move.b	sra(a0),d1
00000476  0801 0002                        107  		btst	#txrdy,d1
0000047A  67F6                             108  		beq	opoll_a
0000047C  1140 0007                        109  		move.b	d0,tba(a0)
00000480  4CDF 0102                        110  		movem.l	(sp)+,d1/a0
00000484  4E73                             111  		rte
00000486                                   112  
00000486                                   113  gcha_bs
00000486                                   114  ********************************************************************
00000486                                   115  * name: 	gcha_bs
00000486                                   116  * function:	get character from serial port B subroutine upon an
00000486                                   117  *		interrupt occurance.  Status check not necessary.
00000486                                   118  *		This is different from gchar_b.
00000486                                   119  *
00000486                                   120  * input: 	<none>
00000486                                   121  * output:	D0, received character
00000486                                   122  * registers:	A0,D0
00000486                                   123  *
00000486  48E7 0080                        124  gcha_bs:	movem.l	a0,-(sp)	; receive a byte date from the
0000048A  41F9 00020000                    125  		lea	duart,a0	;    serial port B to d0
00000490  1028 0017                        126  		move.b	rbb(a0),d0	;Remove a byte from the port B.
00000494  4CDF 0100                        127  		movem.l	(sp)+,a0
00000498  4E73                             128  		rte
0000049A                                   129  
0000049A                                   130  ********************************************************************
0000049A                                   131  * name: 	gchar_b
0000049A                                   132  * function:	get character from serial port B subroutine
0000049A                                   133  * input: 	<none>
0000049A                                   134  * output:	D0, received character
0000049A                                   135  * registers:	A0,D0,D1
0000049A                                   136  *
0000049A  48E7 4080                        137  gchar_b:	movem.l	d1/a0,-(sp)	; receive a byte date from the
0000049E  41F9 00020000                    138  		lea	duart,a0	;    serial port B to d0
000004A4  1228 0013                        139  ipoll_b:	move.b	srb(a0),d1	;Get the copy of the port B status.
000004A8  0801 0000                        140  		btst	#rxrdy,d1	;Check to see if a byte data came in.
000004AC  67F6                             141  		beq	ipoll_b		;If no, then loop, wait.
000004AE  1028 0017                        142  		move.b	rbb(a0),d0	;If Yes, remove a byte from the port B.
000004B2  4E43                             143  		trap	#3		; echo print using trap#3
000004B4  B03C 000D                        144  		cmp.b	#$0d,d0		; end of line check
000004B8  6600 000C                        145  		bne	b_e_gchar
000004BC  103C 000A                        146  		move.b	#$0a,d0		; print line-feed
000004C0  4E43                             147  		trap	#3		; pchar_a is trap#3
000004C2  103C 000D                        148  		move.b	#$0d,d0
000004C6  4CDF 0102                        149  b_e_gchar:	movem.l	(sp)+,d1/a0
000004CA  4E73                             150  		rte
000004CC                                   151  ********************************************************************
000004CC                                   152  * name: 	gchar_a
000004CC                                   153  * function:	get character from serial port A subroutine
000004CC                                   154  * input: 	<none>
000004CC                                   155  * output:	D0, received character
000004CC                                   156  * registers:	A0,D0,D1
000004CC                                   157  * 
000004CC  48E7 4080                        158  gchar_a:	movem.l	d1/a0,-(sp)	; receive a byte date from the
000004D0  41F9 00020000                    159  		lea	duart,a0	;    serial port A to d0
000004D6  1228 0003                        160  ipoll_a:	move.b	sra(a0),d1
000004DA  0801 0000                        161  		btst	#rxrdy,d1
000004DE  67F6                             162  		beq	ipoll_a
000004E0  1028 0007                        163  		move.b	rba(a0),d0
000004E4  4E43                             164  		trap	#3		; echo print using trap#3
000004E6  B03C 000D                        165  		cmp.b	#$0d,d0		; end of line check
000004EA  6600 000C                        166  		bne	e_gchar_a
000004EE  103C 000A                        167  		move.b	#$0a,d0		; print line-feed
000004F2  4E43                             168  		trap	#3		; pchar_a is trap#3
000004F4  103C 000D                        169  		move.b	#$0d,d0
000004F8  4CDF 0102                        170  e_gchar_a:	movem.l	(sp)+,d1/a0
000004FC  4E73                             171  		rte
000004FE                                   172  ********************************************************************
000004FE                                   173  * name: 	key_ck_a
000004FE                                   174  * function:	check serial port A for character subroutine
000004FE                                   175  * input: 	<none>
000004FE                                   176  * output:	D0, received character
000004FE                                   177  * registers:	A0,D0,D1
000004FE                                   178  * 
000004FE  48E7 4080                        179  key_ck_a:	movem.l	d1/a0,-(sp)	; Check if any key pressed
00000502  41F9 00020000                    180  		lea	duart,a0	;    serial port A to d0
00000508  4280                             181  		clr.l	d0		; d0=0 if no key pressed.
0000050A  1228 0003                        182  		move.b	sra(a0),d1
0000050E  0801 0000                        183  		btst	#rxrdy,d1
00000512  6700 0004                        184  		beq	e_key_ck_a
00000516  7001                             185  		moveq	#1,d0		; d0=1 if a key pressed.
00000518  4CDF 0102                        186  e_key_ck_a:	movem.l	(sp)+,d1/a0
0000051C  4E73                             187  		rte
0000051E                                   188  *****************************************************************************
0000051E                                   189  *
00000800                                   190  		org	$800		; <<< interrupt 4 occured >>>
00000800  48E7 FFFE                        191                  movem.l	d0-d7/a0-a6,-(sp)
00000804  4E45                             192  		trap	#5		; Upon port B receiving a byte
00000806                                   193  *	data, an interrupt was generated.  So, remove the data just received
00000806                                   194  *	to clear the interrupt, otherwise inturrupt is pending - causing
00000806                                   195  *	consecutive interrupt without break.  TRAP  #5 removes a byte from
00000806                                   196  *	the port B.  The data just received in D0 is useless in the clock
00000806                                   197  *	program, it only serves as generating an interrupt, no other purpose.
00000806                                   198  *
00000806                                   199  *   ENTER YOUR INTERRUPT LEVEL 4 SERVICE ROUTINE HERE!
00000806                                   200  *
00000806                                   201  	* check if the clock is turned on currently
00000806  41F9 000080E7                    202  		lea	clk_on,a0
0000080C  1010                             203  		move.b	(a0),d0
0000080E  B03C 0000                        204  		cmp.b	#0,d0
00000812  6700 01B8                        205  		beq	intQdone		; if not, quickly leave
00000816                                   206  
00000816  41F9 00008021                    207  		lea	save,a0
0000081C  4EB9 00001D98                    208  		jsr	prt_str
00000822  41F9 0000800E                    209        		lea	atr_on,a0
00000828  4EB9 00001D98                    210        		jsr	prt_str			; save the attributes for the current cursor string
0000082E  41F9 00008027                    211        		lea	movec,a0			; string to get to the clock postion
00000834  4EB9 00001D98                    212        		jsr	prt_str
0000083A                                   213  
0000083A                                   214  	* update the clock
0000083A                                   215  
0000083A  43F9 000080DC                    216  	   	lea	cclock,a1			; get the time
00000840  1219                             217  	     	move.b	(a1)+,d1		; get the seconds
00000842  1419                             218  		move.b	(a1)+,d2		; get the minutes
00000844  1619                             219        		move.b	(a1)+,d3		; get the hours
00000846                                   220  
00000846  5201                             221  		add.b	#1,d1		; increment one second
00000848  B23C 003C                        222        		cmp.b	#60,d1	; test if one minute has been up
0000084C  6D00 001C                        223  		blt	e_clock	; if not 60, than don't increment minutes/hours
00000850  4281                             224        		clr.l	d1			; clear seconds to zero
00000852  5202                             225        		add.b	#1,d2		; increment minutes
00000854  B43C 003C                        226        		cmp.b	#60,d2
00000858  6D00 0010                        227        		blt	e_clock	; if not 60 minutes, don't update hours
0000085C  4282                             228        		clr.l	d2
0000085E  5203                             229        		add.b	#1,d3		; increment hours
00000860  B63C 0018                        230        		cmp.b	#24,d3	; check if day is done
00000864  6D00 0004                        231        		blt	e_clock
00000868  4283                             232        		clr.l	d3			; clear the hours
0000086A                                   233  
0000086A                                   234  e_clock:	* time to print the current time, first have to translate it
0000086A                                   235  		* first save the new time
0000086A  1303                             236  		move.b	d3,-(a1)
0000086C  1302                             237  		move.b	d2,-(a1)
0000086E  1301                             238  		move.b	d1,-(a1)
00000870  43F9 00008097                    239  		lea	sclock,a1	; get address of the string
00000876  D3FC 00000008                    240        		adda.l	#8,a1		; offset to the actual location.
0000087C  183C 0000                        241        		move.b	#0,d4		; turn off the leading zeros
00000880  4EB9 00001D22                    242  		jsr	t_time
00000886  41F9 00008097                    243        		lea	sclock,a0
0000088C  4EB9 00001D98                    244        		jsr	prt_str
00000892                                   245  
00000892                                   246  ********************************************************************
00000892                                   247  * check for the timer
00000892                                   248  
00000892  41F9 000080E5                    249  		lea	tmr_on,a0
00000898  1010                             250  		move.b	(a0),d0
0000089A  B03C 0000                        251  		cmp.b	#0,d0		; check if the timer is turned on
0000089E  6700 00C0                        252  		beq	ckalarm	; if zero, it's off, so check the timer
000008A2  41F9 000080DF                    253  		lea	ctimer,a0
000008A8  1218                             254  		move.b	(a0)+,d1
000008AA  1418                             255  		move.b	(a0)+,d2
000008AC  1618                             256  		move.b	(a0)+,d3
000008AE                                   257  	
000008AE                                   258  	* subtract one second  ===========================================
000008AE  B23C 0000                        259  		cmp.b	#0,d1	; check if the seconds are empty
000008B2  6700 0008                        260  		beq	tmrsecs
000008B6  5301                             261  		sub.b	#1,d1
000008B8  6000 002C                        262  		bra	tmrprt
000008BC  123C 003B                        263  tmrsecs:	move.b	#59,d1
000008C0  B43C 0000                        264  		cmp.b	#0,d2	; check if the minutes are emtpy
000008C4  6700 0008                        265  		beq	tmrmin
000008C8  5302                             266  		sub.b	#1,d2	; otherwise decrement the minutes
000008CA  6000 001A                        267  		bra	tmrprt
000008CE  143C 003B                        268  tmrmin:		move.b	#59,d2	; set the number of minutes
000008D2  B63C 0000                        269  		cmp.b	#0,d3	; check to make sure there wasn't an error
000008D6  6700 0008                        270  		beq	tmrerr
000008DA  5383                             271  		sub.l	#1,d3	; otherwise subtract the amount from the hours
000008DC  6000 0008                        272  		bra	tmrprt
000008E0  4281                             273  tmrerr:		clr.l	d1
000008E2  4282                             274  		clr.l	d2
000008E4  4283                             275  		clr.l	d3	; if error, turn the alarm off
000008E6                                   276  	* print the timer ================================================
000008E6                                   277  tmrprt:	* translate the timer into a string
000008E6                                   278  
000008E6                                   279  	* after the update, we need to check that the timer isn't done yet
000008E6  B23C 0000                        280  		cmp.b	#0,d1
000008EA  6600 003A                        281  		bne	tmprt2
000008EE  B43C 0000                        282  		cmp.b	#0,d2
000008F2  6600 0032                        283  		bne	tmprt2
000008F6  B63C 0000                        284  		cmp.b	#0,d3
000008FA  6600 002A                        285  		bne	tmprt2
000008FE                                   286  
000008FE                                   287  	* else it's zero, and the alarm is going to go off
000008FE  41F9 000080E5                    288  		lea	tmr_on,a0
00000904  10BC 0000                        289  		move.b	#0,(a0)		; turn the alarm off for future interrupts
00000908                                   290  	* emit an audible sound ( \a in c )
00000908  103C 0007                        291  		move.b	#7,d0
0000090C  4E43                             292  		trap	#3		; set off a bell
0000090E                                   293  	* print the message
0000090E  41F9 00008048                    294  		lea	movMsg,a0
00000914  4EB9 00001D98                    295  		jsr	prt_str
0000091A  41F9 00008063                    296  		lea	tmrMsg,a0
00000920  4EB9 00001D98                    297  		jsr	prt_str
00000926                                   298  
00000926                                   299  	* actual printing of the timer string
00000926  43F9 000080AE                    300  tmprt2:		lea	stimer,a1
0000092C  D3FC 00000008                    301  		adda.l	#8,a1		; offset to the correct part in string
00000932  183C 0001                        302  		move.b	#1,d4		; turn leading zeros on
00000936  4EB9 00001D22                    303  		jsr	t_time		; go and translate
0000093C                                   304  
0000093C  41F9 0000803D                    305  		lea	movtmr,a0	; string to move to the timer
00000942  4EB9 00001D98                    306  		jsr	prt_str		; move there
00000948  41F9 000080AE                    307  		lea	stimer,a0	; get the string of the timer
0000094E  4EB9 00001D98                    308  		jsr	prt_str
00000954                                   309  		
00000954  41F9 000080DF                    310  		lea	ctimer,a0
0000095A  10C1                             311  		move.b	d1,(a0)+
0000095C  10C2                             312  		move.b	d2,(a0)+
0000095E  10C3                             313  		move.b	d3,(a0)+	; save the new time
00000960                                   314  
00000960                                   315  	* all done with the timer ---------------------------------------------
00000960                                   316  
00000960                                   317  ***************
00000960                                   318  * alarm stuff
00000960  41F9 000080E6                    319  ckalarm:	lea	alrm_on,a0
00000966  0C10 0000                        320  		cmpi.b	#0,(a0)		; check if alarm is off
0000096A  6700 0048                        321  		beq	intdone
0000096E                                   322  	* otherwise, the alarm is ready to run.
0000096E  43F9 000080E2                    323  		lea	calarm,a1	; memory of the alarm setting
00000974  45F9 000080DC                    324  		lea	cclock,a2	; the memory of the current time
0000097A                                   325  	* to see if the alarm has gone off, check to see if it is the same
0000097A                                   326  	* time as the current time
0000097A  B509                             327  		cmpm.b	(a1)+,(a2)+	; check the seconds
0000097C  6600 0036                        328  		bne	intdone
00000980  B509                             329  		cmpm.b	(a1)+,(a2)+	; check the minutes
00000982  6600 0030                        330  		bne	intdone
00000986  B509                             331  		cmpm.b	(a1)+,(a2)+	; check hours
00000988  6600 002A                        332  		bne	intdone
0000098C                                   333  	* at this point, the alarm is to go off, beep for the user
0000098C  103C 0007                        334  		move.b	#7,d0
00000990  4E43                             335  		trap	#3
00000992  103C 0007                        336  		move.b	#7,d0
00000996  4E43                             337  		trap	#3		; do it twice to be different than the timer
00000998                                   338  		
00000998  10BC 0000                        339  		move.b	#0,(a0)		; turn the alarm off
0000099C  41F9 00008048                    340  		lea	movMsg,a0
000009A2  4EB9 00001D98                    341  		jsr	prt_str		; go to the message section
000009A8                                   342  
000009A8  41F9 0000807D                    343  		lea	almMsg,a0
000009AE  4EB9 00001D98                    344  		jsr	prt_str
000009B4                                   345  
000009B4                                   346  		
000009B4                                   347  ***************************************************************************
000009B4                                   348  *	The following lines return the cursor back to it's position before the interrupt
000009B4  41F9 0000801B                    349  intdone:	lea	atr_off,a0
000009BA  4EB9 00001D98                    350  		jsr	prt_str			; turn the regular character attributes back on
000009C0  41F9 00008024                    351  		lea	load,a0
000009C6  4EB9 00001D98                    352  		jsr	prt_str
000009CC  4CDF 7FFF                        353  intQdone:	movem.l	(sp)+,d0-d7/a0-a6
000009D0  4E73                             354  		rte			; <<< interrupt 4 occured >>>
000009D2                                   355  *
000009D2                                   356  ******************************************************************************
000009D2                                   357  *
00008000                                   358  		org	$8000
00008000                                   359  *
00008000                                   360  *   IF YOU NEED MEMORY SPACE, RESERVE THEM HERE.
00008000                                   361  *
00008000                                   362  
00008000                                   363  * strings to mess with the terminal window.
00008000                                   364  
00008000  1B 5B 31 33 3B 32 35 72 00       365  scroll_msg:	dc.b	$1b,'[13;25r',0      	; set the scroll portion of screen
00008009                                   366  		ds.b	5
0000800E  1B 1B 5B 31 3B 37 6D 00          367  atr_on:		dc.b	$1b,$1b,'[1;7m',0    	; turn bold, reverse video on.
00008016                                   368  		ds.b	5			; buffer
0000801B  1B 1B 5B 30 6D 00                369  atr_off:	dc.b	$1b,$1b,'[0m',0	   	; turn off char attributes
00008021  1B 37 00                         370  save:		dc.b	$1b,'7',0		; save current cursor position
00008024  1B 38 00                         371  load:		dc.b	$1b,'8',0		; reload the cursor settings
00008027  1B 1B 5B 34 3B 33 32 48 00       372  movec:		dc.b	$1b,$1b,'[4;32H',0		; move to the clock
00008030                                   373  		ds.b	2			; needed for tetris
00008032  1B 1B 5B 35 3B 33 32 48 00       374  movalm:		dc.b	$1b,$1b,'[5;32H',0		; move to the alarm
0000803B                                   375  		ds.b	2			; needed for tetris
0000803D  1B 1B 5B 36 3B 33 32 48 00       376  movtmr:		dc.b	$1b,$1b,'[6;32H',0		; move to the timer
00008046                                   377  		ds.b	2			; needed for tetris
00008048  1B 1B 5B 38 3B 32 38 48 00       378  movMsg:         dc.b	$1b,$1b,'[8;28H',0		; position output msg
00008051                                   379  		ds.b	2
00008053  1B 1B 5B 31 33 3B 30 48 00       380  gfx:		dc.b	$1b,$1b,'[13;0H',0		; graphics character set
0000805C  1B 5B 30 3B 30 48 00             381  xy_init:	dc.b	$1b,'[0;0H',0
00008063                                   382  
00008063  20 54 68 65 20 74 69 6D 65 ...   383  tmrMsg:		dc.b	' The timer has expired.  ',0
0000807D  20 54 68 65 20 61 6C 61 72 ...   384  almMsg:		dc.b	' The alarm has gone off. ',0
00008097                                   385  
00008097  20 43 6C 6F 63 6B 3A 20 20 ...   386  sclock:		dc.b	' Clock:               ',0
000080AE  20 54 69 6D 65 72 3A 20 20 ...   387  stimer:		dc.b	' Timer:               ',0
000080C5  20 41 6C 61 72 6D 3A 20 20 ...   388  salarm:		dc.b	' Alarm:               ',0
000080DC  00 00 00                         389  cclock:		dc.b	0,0,0		; space for seconds, minutes and hours
000080DF  00 00 00                         390  ctimer:		dc.b    0,0,0		; space for the timer (countdown)
000080E2  00 00 00                         391  calarm:		dc.b	0,0,0		; space for the alarm
000080E5  00                               392  tmr_on:		dc.b	0
000080E6  00                               393  alrm_on:	dc.b	0		; bytes to determine if the timer/alarm is on or off
000080E7  01                               394  clk_on:		dc.b	1		; is the clock on or off?
000080E8                                   395  
000080E8  1B 5B 31 6D                      396  ihdr1:		dc.b	$1b,'[1m'  		; turn boldface on
000080EC  20 43 6C 6F 63 6B 20 70 72 ...   397  		dc.b	' Clock program using level 4 interrupts,'
00008114  20 62 79 20 4A 61 73 6F 6E ...   398  		dc.b	' by Jason F Smith.  Choose your option'
0000813A  0A 0D                            399  		dc.b	$0a,$0d
0000813C  20 20 61 20 2D 20 73 65 74 ...   400  		dc.b	'  a - set alarm         c - set timer    s - set time'
00008171  0A 0D                            401  		dc.b	$0a,$0d
00008173  20 20 70 20 2D 20 72 75 6E ...   402  		dc.b	'  p - run calculator    t - tetris       q - quit'
000081A4  0A 0D 0A 0D                      403  		dc.b	$0a,$0d,$0a,$0d
000081A8  20 3E 3E 20                      404  		dc.b	' >> '
000081AC  1B 5B 30 6D 00                   405  		dc.b	$1b,'[0m',0		; turn attributes off
000081B1  20 45 6E 74 65 72 20 74 68 ...   406  ihdr2:		dc.b	' Enter the time (hh:mm:ss): ',0
000081CE  20 49 6E 76 61 6C 69 64 20 ...   407  ihdr3:		dc.b	' Invalid input, make sure you enter as hh:mm:ss.',$0a,$0d,0
00008201  20 54 68 65 20 63 6C 6F 63 ...   408  ihdr4:		dc.b	' The clock could not be set.',$0a,$0d,0
00008220  20 54 68 65 20 63 6C 6F 63 ...   409  ihdr5:		dc.b	' The clock has been set.',$0a,$0d,0
0000823B  20 54 68 65 20 74 69 6D 65 ...   410  ihdr6:		dc.b	' The timer has been set.',$0a,$0d,0
00008256  20 54 68 65 20 74 69 6D 65 ...   411  ihdr7:		dc.b	' The timer could not be set.',$0a,$0d,0
00008275  20 54 68 65 20 61 6C 61 72 ...   412  ihdr8:		dc.b	' The alarm has been set.',$0a,$0d,0
00008290  20 54 68 65 20 61 6C 61 72 ...   413  ihdr9:		dc.b	' The alarm could not be set.',$0a,$0d,0
000082AF  20 20 20 20 20 20 20 20 20 ...   414  empty:		dc.b	'                      ',0		; used to erase the output
000082C6                                   415  ************************************************************************
000082C6                                   416  *  The following data space is for the calculator of HW #8
000082C6  20 20 20 20 20 52 75 6E 6E ...   417  line1:		dc.b	'     Runnning a 32-bit integer calculator program.'
000082F8  0A 0D 20 20 20 20 20 54 6F ...   418  		dc.b	$0a,$0d,'     To end, type "exit"',$0a,$0d
00008314  20 20 20 20 20 4E 6F 74 65 ...   419  		dc.b	'     Note: <BACKSPACE> can be used to delete.',$0a,$0d,0
00008344                                   420  
00008344  49 6E 70 75 74 20 3E 20 00       421  prompt:		dc.b	'Input > ',0
0000834D  41 6E 73 77 65 72 3A 20 00       422  answer:		dc.b	'Answer: ',0
00008356                                   423  
00008356                                   424  		ds.b	20	; stack for operators
0000836A                                   425  input:		ds.b	51	; used to store the input (extra space for NULL)
0000839D                                   426  output:		ds.b	60	; used to store the output of the preprocesor
000083D9                                   427  expres:		ds.b	80	; the postfix notated expression
00008429  32                               428  maxin:		dc.b	50	; maximum number of characters for input
0000842A  00000000                         429  error:		dc.l	0	; used for error checking in the in2pos subroutine
0000842E  57 41 52 4E 49 4E 47 3A 20 ...   430  warning:	dc.b	'WARNING: Maximum number of input characters reached.  Input terminated.',$0a,$0d,0
00008478  54 68 65 20 69 6E 70 75 74 ...   431  yesError:	dc.b	'The input string contained the following error(s):',$0a,$0d,0
000084AD  4E 6F 20 65 72 72 6F 72 73 ...   432  noError:	dc.b	'No errors found in the input string.',$0a,$0d,0
000084D4  20 20 20 20 20 49 6E 70 75 ...   433  errorA:		dc.b	'     Input operand is too large (more than 10 characters).',$0a,$0d,0
00008511  20 20 20 20 20 49 6C 6C 65 ...   434  errorB:		dc.b	'     Illegal operation: Multiple operators.',$0a,$0d,0
0000853F  20 20 20 20 20 45 78 70 72 ...   435  errorC:		dc.b	'     Expression is missing right parenthesis.',$0a,$0d,0
0000856F  20 20 20 20 20 45 78 70 72 ...   436  errorD:		dc.b	'     Expression is missing left parenthesis.',$0a,$0d,0
0000859E  20 20 20 20 20 4F 70 65 72 ...   437  errorE:		dc.b	'     Operator without operand(s).',$0a,$0d,0
000085C2  20 20 20 20 20 41 6E 20 75 ...   438  errorF:		dc.b	'     An unrecognized character was found.',$0a,$0d,0
000085EE  20 20 20 20 20 45 6D 70 74 ...   439  errorG:		dc.b	'     Empty set of parenthesis was found.',$0a,$0d,0
00008619                                   440  		ds.b	20	; temporary stack for the in2pos translator
0000862D  00                               441  stack:		dc.b	0	; 'top' of stack
0000862E  54 68 65 20 6F 75 74 70 75 ...   442  head2:		dc.b	'The output from the preprocessor was:',$0a,$0d,'     ',0
0000865B  54 68 69 73 20 70 72 6F 67 ...   443  head3:		dc.b	'This program can also print the output from the'
0000868A  20 70 72 65 70 72 6F 63 65 ...   444  		dc.b	' preprocessor.',$0a,$0d
0000869A  57 6F 75 6C 64 20 79 6F 75 ...   445  		dc.b	'Would you like to see it? (Y/N) >> ',0
000086BE  00                               446  see_pre:	dc.b	0	; a byte to determine if pre proc is shown.
000086BF                                   447  
000086BF                                   448  
000086BF                                   449  * data added for hw8, above is the exact same as hw7 data.
000086BF                                   450  
000086BF  43 68 6F 6F 73 65 20 61 20 ...   451  qstion:		dc.b	'Choose a format that you will be entering: Infix/Postfix (I/P) >> ',0
00008702  00                               452  uansr:		dc.b	0		; used to store the answer of above question. 0-postfix, 1-infix
00008703  45 78 70 72 65 73 73 69 6F ...   453  answrI:		dc.b	'Expression error checking is on.',$0a,$0d,0
00008726  45 72 72 6F 72 20 63 68 65 ...   454  answrP:		dc.b	'Error checking is off.',$0a,$0d,0
00008740                                   455  		ds.l	15		; stack used when calculating the answer.
0000877C  00000000                         456  cstack:		dc.l	0
00008780  00                               457  		dc.b	0
00008781  65 78 69 74 00                   458  exit:		dc.b	'exit',0
00008786  0A 0D 20 20 45 78 69 74 69 ...   459  bye:		dc.b	$0a,$0d,'  Exiting...',$0a,$0d,0
00008798  00000000                         460  result:		dc.l	0
0000879C                                   461  
0000879C  20 45 72 72 6F 72 3A 20 4F ...   462  cerrorA:	dc.b	' Error: Overflow during addition.',$0a,$0d,0
000087C0  20 45 72 72 6F 72 3A 20 4F ...   463  cerrorB:	dc.b	' Error: Overflow during subtraction.',$0a,$0d,0
000087E7  20 45 72 72 6F 72 3A 20 4F ...   464  cerrorC:	dc.b	' Error: Overflow during multiplication.',$0a,$0d,0
00008811  20 45 72 72 6F 72 3A 20 4F ...   465  cerrorD:	dc.b	' Error: Operand overflow (too large/small).',$0a,$0d,0
0000883F  20 45 72 72 6F 72 3A 20 44 ...   466  cerrorE:	dc.b	' Error: Divide by zero.',$0a,$0d,0
00008859                                   467  
00008859  00                               468  cerrflg:	dc.b	0
0000885A                                   469  ******************************************************************************
0000885A                                   470  *  Data needed for Tetris game
0000885A  1B 5B 31 6D                      471  screen:		dc.b	$1b,'[1m'			; bold face
0000885E  1B 5B 31 3B 31 48                472  		dc.b	$1b,'[1;1H'				; move to (1,1) on screen
00008864  20 2B 2D 2D 2D 2D 2D 2D 2D ...   473  		dc.b	' +----------+ ',$0a,$0d	; top of screen
00008874  20 7C 20 20 20 20 20 20 20 ...   474  field:		dc.b	' |          | ',$0a,$0d	; top line
00008884  20 7C 20 20 20 20 20 20 20 ...   475  		dc.b	' |          | ',$0a,$0d	; 19th line...
00008894  20 7C 20 20 20 20 20 20 20 ...   476  		dc.b	' |          | ',$0a,$0d	;**************************************
000088A4  20 7C 20 20 20 20 20 20 20 ...   477  		dc.b	' |          | ',$0a,$0d	; The field is arranged so that
000088B4  20 7C 20 20 20 20 20 20 20 ...   478  		dc.b	' |          | ',$0a,$0d	; the origin is at (0,0), which
000088C4  20 7C 20 20 20 20 20 20 20 ...   479  		dc.b	' |          | ',$0a,$0d	; is at the top left.
000088D4  20 7C 20 20 20 20 20 20 20 ...   480  		dc.b	' |          | ',$0a,$0d	; the max is (9,19) at bottom right
000088E4  20 7C 20 20 20 20 20 20 20 ...   481  		dc.b	' |          | ',$0a,$0d	;**************************************
000088F4  20 7C 20 20 20 20 20 20 20 ...   482  		dc.b	' |          | ',$0a,$0d
00008904  20 7C 20 20 20 20 20 20 20 ...   483  		dc.b	' |          | ',$0a,$0d
00008914  20 7C 20 20 20 20 20 20 20 ...   484  		dc.b	' |          | ',$0a,$0d	; 10th line
00008924  20 7C 20 20 20 20 20 20 20 ...   485  		dc.b	' |          | ',$0a,$0d
00008934  20 7C 20 20 20 20 20 20 20 ...   486  		dc.b	' |          | ',$0a,$0d
00008944  20 7C 20 20 20 20 20 20 20 ...   487  		dc.b	' |          | ',$0a,$0d
00008954  20 7C 20 20 20 20 20 20 20 ...   488  		dc.b	' |          |    < - move left',$0a,$0d
00008974  20 7C 20 20 20 20 20 20 20 ...   489  		dc.b	' |          |    > - move right',$0a,$0d	; 5th line
00008995  20 7C 20 20 20 20 20 20 20 ...   490  		dc.b	' |          |    / - move down',$0a,$0d
000089B5  20 7C 20 20 20 20 20 20 20 ...   491  		dc.b	' |          |    z - rotate left',$0a,$0d
000089D7  20 7C 20 20 20 20 20 20 20 ...   492  		dc.b	' |          |    x - rotate right',$0a,$0d
000089FA  20 7C 20 20 20 20 20 20 20 ...   493  		dc.b	' |          |    ESC/1 - quit',$0a,$0d	; 1st line
00008A19  20 2B 2D 2D 2D 2D 2D 2D 2D ...   494  		dc.b	' +----------+ ',$0a,$0d		; bottom of screen
00008A29  20 20 20 20 54 45 54 52 49 ...   495  		dc.b	'    TETRIS    ',0 
00008A38                                   496  i_type:		ds.b	1		; data for the current item
00008A39                                   497  *	Type:	$01 - Block
00008A39                                   498  *		$02 - Long
00008A39                                   499  *		$03 - S
00008A39                                   500  *		$04 - rev S
00008A39                                   501  *		$05 - L
00008A39                                   502  *		$06 - rev L
00008A39                                   503  *		$07 - T
00008A39                                   504  
00008A39                                   505  i_pos:		ds.b	1
00008A3A                                   506  *	Postion:
00008A3A                                   507  *		$01 - up (original)
00008A3A                                   508  *		$02 - left
00008A3A                                   509  *		$04 - down
00008A3A                                   510  *		$08 - right
00008A3A                                   511  
00008A3A                                   512  i_xy:		ds.w	1	; the x,y of the item, used to plot the item
00008A3C                                   513  i_pts:		ds.w	4	; the x,y of each 'block' of the item
00008A44                                   514  t_pts:		ds.w	4	; temp points for moving/dropping
00008A4C                                   515  t_xy:		ds.w	1
00008A4E                                   516  prevsecs:	ds.b	1
00008A4F                                   517  
00008A4F  1B 5B 31 3B 32 35 72 00          518  setscroll:	dc.b	$1b,'[1;25r',0	; back to the complete screen
00008A57                                   519  		ds.b	5
00008A5C  1B 1B 5B 31 30 3B 33 35 48 00    520  nmovC:		dc.b	$1b,$1b,'[10;35H',0		; new position for clock
00008A66                                   521  		ds.b	2			; buffer
00008A68  1B 1B 5B 31 31 3B 33 35 48 00    522  nmovA:		dc.b	$1b,$1b,'[11;35H',0		; new pos for alarm
00008A72                                   523  		ds.b	2			; buffer
00008A74  1B 1B 5B 31 32 3B 33 35 48 00    524  nmovT:		dc.b	$1b,$1b,'[12;35H',0		; new position for timer
00008A7E                                   525  		ds.b	2			; needed as a buffer
00008A80  1B 1B 5B 31 34 3B 33 30 48 00    526  nmovMsg:	dc.b	$1b,$1b,'[14;30H',0		; new postion for the message output
00008A8A                                   527  		ds.b	2
00008A8C  1B 1B 5B 32 32 3B 31 35 48 00    528  movBack:	dc.b	$1b,$1b,'[22;15H',0
00008A96                                   529  
00008A96  20 49 6E 69 74 69 61 6C 69 ...   530  Msgaaa:	dc.b	' Initializing Tetris by Jason F Smith....',$0a,$0d,0
00008AC2  1B 5B 32 4A 00                   531  Msgaab:	dc.b	$1b,'[2J',0		; erase the entire screen
00008AC7  1B 5B 30 6D 00                   532  newattr:	dc.b	$1b,'[0m',0
00008ACC                                   533  		ds.b	7
00008AD3  1B 1B 5B 31 6D 00                534  new_off:	dc.b	$1b,$1b,'[1m',0
00008AD9                                   535  		ds.b	7
00008AE0                                   536  field2:		ds.b	320	; 20 rows * 10 columns,... 16 bytes per row to assist in jumping around
00008C20                                   537  e_field2:	ds.b	1
00008C21                                   538  * raw data, supposedly random, but I just typed them all in, close enough I guess
00008C21  03 07 05 01 02 05 07 06 03 ...   539  data:		dc.b	3,7,5,1,2,5,7,6,3,4,4,1,5,2,7,6,4,2,3,1,5,6,7,3,1,4,2,6,6,4,7,6,1,3,2,4,7
00008C46  01 01 05 03 04 07 06 02 07 ...   540  		dc.b	1,1,5,3,4,7,6,2,7,1,4,3,5,6,3,2,4,5,1,1,7,1,3,2,5,3,1,2,5,4,3,2,6,1,5,3,7
00008C6B  04 06 02 07 03 04 02 01 05 ...   541  		dc.b	4,6,2,7,3,4,2,1,5,3,6,4,5,7,3,5,1,2,3,6,7,1,2,3,6,1,3,4,3,5,2,6,4,7,1,1,2
00008C90  07 04 05 03 06 01 07 02 05 ...   542  		dc.b	7,4,5,3,6,1,7,2,5,3,5,4,7,6,5,3,5,1,2,7,4,6,1,7,3,3,4,5,2,1,5,6,1,7,3,5,4
00008CB5  03 07 02 05 03 07 03 04 02 ...   543  		dc.b	3,7,2,5,3,7,3,4,2,1,4,3,1,3,2,6,4,7,2,5,3,7,2,4,1,5,3,4,1,2,6,7,2,1,4,1,4
00008CDA  02 06 07 01 04 02 05 04 01 ...   544  		dc.b	2,6,7,1,4,2,5,4,1,6,7,5,4,2,3,1,6,7,3,4,2,5,6,7,7,1,1,4,2,3,5,1,3,4,2,5,5
00008CFF  02                               545  enddata:	dc.b	2
00008D00  1B 5B                            546  g_xy:		dc.b	$1b,'['
00008D02  0A                               547  x_y:		dc.b	10
00008D03                                   548  *****************************************************************************
00008D03                                   549  *
00001000                                   550  		org	$1000		; Main program start here
00001000  4E40                             551  start:		trap	#0		; initialize serial port driver
00001002                                   552  *
00001002                                   553  *   ENTER YOUR HW9 PROGRAM HERE!
00001002                                   554  *
00001002  4E71                             555  CLOCK:		nop			; This is interrupt driven CLOCK!
00001004                                   556       * initialize the clock and screen
00001004  41F9 0000800E                    557  		lea	atr_on,a0
0000100A  4EB9 00001D98                    558  		jsr	prt_str
00001010                                   559  		
00001010  4281                             560  		clr.l	d1
00001012  103C 0020                        561  		move.b	#' ',d0
00001016  323C 03C0                        562  		move.w	#960,d1		; 80*12=960 white spaces
0000101A  6000 0004                        563  		bra	spTst
0000101E  4E43                             564  spLp:		trap	#3
00001020  51C9 FFFC                        565  spTst:		dbra	d1,spLp
00001024  41F9 0000801B                    566  		lea	atr_off,a0
0000102A  4EB9 00001D98                    567  		jsr	prt_str
00001030                                   568  
00001030  41F9 00008000                    569        		lea   	scroll_msg,a0
00001036  4EB9 00001D98                    570        		jsr	prt_str		; set the scroll mode on
0000103C                                   571  
0000103C                                   572  * The following three lines are necessary to start 1 sec. timing.
0000103C                                   573  * Execute when ready to tick.
0000103C  46FC 2000                        574  		move.w	#$2000,sr	; Enable interrupt, all levels.
00001040  103C 000A                        575  		move.b	#10,D0		; Command the 1sec timer in port B
00001044  4E47                             576  		trap	#7		;   to start.  TRAP #7 writes to
00001046                                   577  
00001046  4280                             578  		clr.l	d0
00001048  41F9 00008053                    579  		lea	gfx,a0		; goto the correct cursor position
0000104E  4EB9 00001D98                    580  		jsr	prt_str
00001054                                   581  
00001054                                   582  main:	* print the header for the user to choose.
00001054  41F9 000080E8                    583  		lea	ihdr1,a0
0000105A  4EB9 00001D98                    584  		jsr	prt_str
00001060                                   585  	* get the users input and process it
00001060  4E41                             586  mn_poll:	trap	#1		; check for input
00001062  B03C 0000                        587  		cmp.b	#0,d0
00001066  67F8                             588  		beq	mn_poll		; wait until input
00001068                                   589  
00001068  4E42                             590  		trap	#2		; actually get the input, now process
0000106A                                   591  		
0000106A  B03C 0061                        592  		cmp.b	#'a',d0		; check for alarm
0000106E  6700 003C                        593  		beq	inAlarm
00001072  B03C 0063                        594  		cmp.b	#'c',d0		; check for countdown timer
00001076  6700 00D0                        595  		beq	inTimer	
0000107A  B03C 0070                        596  		cmp.b	#'p',d0		; check for calculator
0000107E  6700 0114                        597  		beq	inCalc
00001082  B03C 0073                        598  		cmp.b	#'s',d0		; set the clock
00001086  6700 0116                        599  		beq	inClock
0000108A  B03C 0071                        600  		cmp.b	#'q',d0
0000108E  6700 0150                        601  		beq	inQuit
00001092  B03C 0031                        602  		cmp.b	#'1',d0
00001096  6700 0148                        603  		beq	inQuit
0000109A  B03C 0074                        604  		cmp.b	#'t',d0
0000109E  6700 0004                        605  		beq	plytetris
000010A2                                   606  
000010A2  60BC                             607  		bra	mn_poll		; if not a valid input, keep waiting
000010A4                                   608  
000010A4  4EB9 000011F0                    609  plytetris:	jsr	tetris
000010AA  60A8                             610  		bra	main
000010AC                                   611  
000010AC  4EB9 00001BE8                    612  inAlarm:	jsr	rd_time		; read in the time
000010B2  B03C 0000                        613  		cmp.b	#0,d0		; check if invalid input
000010B6  6700 0080                        614  		beq	AlmNoGd
000010BA                                   615  
000010BA  43F9 000080C5                    616  		lea	salarm,a1	; get addresss of the string
000010C0  D3FC 00000008                    617  		adda.l	#8,a1		; offset to the alarm time
000010C6  4284                             618  		clr.l	d4		; turn leading zeros off
000010C8  4EB9 00001D22                    619  		jsr	t_time		; translate to a string
000010CE                                   620  	* The following lines are a 'mini' critical section, for several reasons
000010CE                                   621  	* If the interrupt hits while in here, several things may happen,
000010CE                                   622  	* 1 - the save and restore of the cursor could get messed up
000010CE                                   623  	* 2 - if an interrupt occurs while the alarm time is being saved, the
000010CE                                   624  	*     alarm could be updated with incorrect amounts in memory (correct 
000010CE                                   625  	*     seconds, but not hours and minutes for example )
000010CE                                   626  
000010CE  46FC 2700                        627  		move.w	#$2700,sr		; turn interrupts off briefly
000010D2                                   628  
000010D2  43F9 000080E2                    629  		lea	calarm,a1	; get address of the actual alarm in memory
000010D8  12C1                             630  		move.b	d1,(a1)+	; save seconds
000010DA  12C2                             631  		move.b	d2,(a1)+	; minutes
000010DC  12C3                             632  		move.b	d3,(a1)+	; hours
000010DE  41F9 00008021                    633  		lea	save,a0		
000010E4  4EB9 00001D98                    634  		jsr	prt_str
000010EA  41F9 0000800E                    635  		lea	atr_on,a0	; get the attributes (reverse lettering, bold)
000010F0  4EB9 00001D98                    636  		jsr	prt_str
000010F6  41F9 00008032                    637  		lea	movalm,a0	; print the time the alarm will go off
000010FC  4EB9 00001D98                    638  		jsr	prt_str
00001102  41F9 000080C5                    639  		lea	salarm,a0
00001108  4EB9 00001D98                    640  		jsr	prt_str
0000110E  41F9 00008024                    641  		lea	load,a0
00001114  4EB9 00001D98                    642  		jsr	prt_str		; restore the cursor
0000111A  46FC 2000                        643  		move.w	#$2000,sr		; turn interrupts back on, if there was
0000111E                                   644  						* an interrupt during the section, it will occur now
0000111E                                   645  	* end of mini critical section ***********************************************
0000111E  41F9 000080E6                    646  		lea	alrm_on,a0
00001124  10BC 0001                        647  		move.b	#1,(a0)		; turn the alarm on
00001128  41F9 00008275                    648  		lea	ihdr8,a0	; print alarm set heading
0000112E  4EB9 00001D98                    649  		jsr	prt_str
00001134  6000 FF1E                        650  		bra	main		; loop again
00001138                                   651  
00001138  41F9 00008290                    652  AlmNoGd:	lea	ihdr9,a0	; load error message
0000113E  4EB9 00001D98                    653  		jsr	prt_str		; and print it
00001144  6000 FF0E                        654  		bra	main		; return to the prompt again
00001148                                   655  
00001148                                   656  
00001148  4EB9 00001BE8                    657  inTimer:	jsr	rd_time		; read in the time from the user
0000114E  B03C 0000                        658  		cmp.b	#0,d0		; test if valid
00001152  6700 0030                        659  		beq	TmrNoGd		; if not a valid
00001156                                   660  	* unlike the alarm, the timer is update on every tick, so
00001156                                   661  	* it isn't necessary to print it out here, it does it in the
00001156                                   662  	* interrupt.  It does need turned on though
00001156  46FC 2700                        663  		move.w	#$2700,sr	; temp turn off clock
0000115A  41F9 000080E5                    664  		lea	tmr_on,a0
00001160  10BC 0001                        665  		move.b	#1,(a0)		; turn the timer on
00001164  43F9 000080DF                    666  		lea	ctimer,a1
0000116A  12C1                             667  		move.b	d1,(a1)+
0000116C  12C2                             668  		move.b	d2,(a1)+
0000116E  12C3                             669  		move.b	d3,(a1)+	; store the timer values
00001170  46FC 2000                        670  		move.w	#$2000,sr	; turn interrupts back on
00001174  41F9 0000823B                    671  		lea	ihdr6,a0
0000117A  4EB9 00001D98                    672  		jsr	prt_str
00001180  6000 FED2                        673  		bra	main
00001184                                   674  
00001184  41F9 00008256                    675  TmrNoGd:	lea	ihdr7,a0
0000118A  4EB9 00001D98                    676  		jsr	prt_str
00001190  6000 FEC2                        677  		bra	main		; return to the prompt again
00001194                                   678  
00001194                                   679  
00001194  4EB9 00001E02                    680  inCalc:		jsr	hw9Calc		; go to the calculator	
0000119A  6000 FEB8                        681  		bra	main		; return to the prompt again
0000119E                                   682  
0000119E                                   683  
0000119E  4EB9 00001BE8                    684  inClock:	jsr	rd_time
000011A4  B03C 0000                        685  		cmp.b	#0,d0
000011A8  6700 0026                        686  		beq	ClkNoGd
000011AC  43F9 000080DC                    687  		lea	cclock,a1
000011B2  46FC 2700                        688  		move.w	#$2700,sr	; turn off clock temporarily
000011B6  12C1                             689  		move.b	d1,(a1)+
000011B8  12C2                             690  		move.b	d2,(a1)+
000011BA  12C3                             691  		move.b	d3,(a1)+	; save the new time
000011BC  46FC 2000                        692  		move.w	#$2000,sr	; turn clock back on
000011C0  41F9 00008220                    693  		lea	ihdr5,a0
000011C6  4EB9 00001D98                    694  		jsr	prt_str
000011CC  6000 FE86                        695  		bra	main
000011D0                                   696  
000011D0  41F9 00008201                    697  ClkNoGd:	lea	ihdr4,a0
000011D6  4EB9 00001D98                    698  		jsr	prt_str
000011DC  6000 FE76                        699  		bra	main		; return to the prompt again
000011E0                                   700  
000011E0                                   701  
000011E0                                   702  
000011E0  41F9 000080E7                    703  inQuit:		lea	clk_on,a0
000011E6  10BC 0000                        704  		move.b	#0,(a0)		; turn the clock off manually
000011EA  46FC 0A8C                        705  		move.w	#2700,sr	; turn off the interrupt for the clock
000011EE  4AFC                             706  		illegal			; Main program ends here
000011F0                                   707  *
000011F0                                   708  *   PUT YOUR SUBROUTINES HERE!
000011F0                                   709  *
000011F0                                   710  *************************************************************************************
000011F0                                   711  *
000011F0                                   712  *	Tetris program
000011F0                                   713  *	Added just for fun.  It repositions the clock, alarm and timer, which all
000011F0                                   714  *	continue to run while the game runs.
000011F0                                   715  *	Commenting might not be that great....
000011F0                                   716  *
000011F0                                   717  **************************************************************************************
000011F0                                   718  * initialize, replace some of the data for the clock program
000011F0  48E7 FFFF                        719  tetris:	movem.l	d0-d7/a0-a7,-(sp)		; save all registers
000011F4                                   720  	* initialize the clock and stuff
000011F4  41F9 000080E7                    721  		lea		clk_on,a0
000011FA  10BC 0000                        722  		move.b		#0,(a0)			; turn off clock temporarily
000011FE                                   723  
000011FE  46FC 2700                        724  		move.w		#$2700,sr		; turn off interrupts
00001202                                   725  
00001202  43F9 00008A96                    726  		lea		Msgaaa,a1
00001208  4EB9 00001D98                    727  		jsr		prt_str			; print 'Initializing...'
0000120E  41F9 0000801B                    728  		lea		atr_off,a0			; make sure the attributes are off
00001214  4EB9 00001D98                    729  		jsr		prt_str
0000121A                                   730  
0000121A                                   731  	* switch the addresses of the messages so that the time is on a different part of the 
0000121A                                   732  	* screen, they will need to be moved back at the end of the game
0000121A  43F9 00008A4F                    733  		lea		setscroll,a1
00001220  45F9 00008000                    734  		lea		scroll_msg,a2
00001226  4EB9 00001ADA                    735  		jsr		switch			; change the scroll pattern
0000122C  41F9 00008000                    736  		lea		scroll_msg,a0
00001232  4EB9 00001D98                    737  		jsr		prt_str
00001238                                   738  
00001238  43F9 00008A5C                    739  		lea		nmovC,a1			; clock positioning
0000123E  45F9 00008027                    740  		lea		movec,a2			; addresses of the move messages
00001244  4EB9 00001ADA                    741  		jsr		switch
0000124A  43F9 00008A68                    742  		lea		nmovA,a1			; alarm positioning
00001250  45F9 00008032                    743  		lea		movalm,a2
00001256  4EB9 00001ADA                    744  		jsr		switch
0000125C  43F9 00008A74                    745  		lea		nmovT,a1			; timer positioning
00001262  45F9 0000803D                    746  		lea		movTmr,a2
00001268  4EB9 00001ADA                    747  		jsr		switch
0000126E  43F9 00008A80                    748  		lea		nmovMsg,a1			; Msg positioning
00001274  45F9 00008048                    749  		lea		movMsg,a2
0000127A  4EB9 00001ADA                    750  		jsr		switch
00001280                                   751  
00001280  43F9 0000800E                    752  		lea		atr_on,a1			; new attributes
00001286  45F9 00008AC7                    753  		lea		newattr,a2
0000128C  4EB9 00001ADA                    754  		jsr		switch
00001292                                   755  
00001292  43F9 0000801B                    756  		lea		atr_off,a1
00001298  45F9 00008AD3                    757  		lea		new_off,a2
0000129E  4EB9 00001ADA                    758  		jsr		switch
000012A4                                   759  
000012A4                                   760  	* print the clock and the timer/alarm if needed
000012A4  41F9 00008AC2                    761  		lea		Msgaab,a0			; erase the entire screen
000012AA  4EB9 00001D98                    762  		jsr		prt_str
000012B0                                   763  
000012B0  43F9 00008027                    764  		lea		movec,a1
000012B6  4EB9 00001D98                    765  		jsr		prt_str
000012BC  45F9 00008097                    766  		lea		sclock,a2
000012C2  4EB9 00001D98                    767  		jsr		prt_str
000012C8                                   768  
000012C8  43F9 000080E6                    769  		lea		alrm_on,a1
000012CE  1011                             770  		move.b		(a1),d0
000012D0  B03C 0000                        771  		cmp.b		#0,d0
000012D4  6700 001A                        772  		beq		lbl_ad
000012D8  41F9 00008032                    773  		lea		movalm,a0
000012DE  4EB9 00001D98                    774  		jsr		prt_str
000012E4  41F9 000080C5                    775  		lea		salarm,a0
000012EA  4EB9 00001D98                    776  		jsr		prt_str
000012F0                                   777  
000012F0  41F9 000080E5                    778  lbl_ad:		lea		tmr_on,a0
000012F6  1010                             779  		move.b		(a0),d0
000012F8  B03C 0000                        780  		cmp.b		#0,d0
000012FC  6700 001A                        781  		beq		lbl_ae
00001300  41F9 0000803D                    782  		lea		movtmr,a0
00001306  4EB9 00001D98                    783  		jsr		prt_str
0000130C  41F9 000080AE                    784  		lea		stimer,a0
00001312  4EB9 00001D98                    785  		jsr		prt_str
00001318                                   786  
00001318                                   787  lbl_ae:   * print the playing field
00001318  41F9 0000885A                    788  		lea		screen,a0
0000131E  4EB9 00001D98                    789  		jsr		prt_str
00001324                                   790  	* clean out the field
00001324  41F9 00008AE0                    791  		lea		field2,a0
0000132A  43F9 00008C20                    792  		lea		e_field2,a1
00001330  10FC 0020                        793  lbl_zxc:	move.b		#' ',(a0)+
00001334  B1C9                             794  		cmpa.l		a1,a0
00001336  6DF8                             795  		blt		lbl_zxc
00001338                                   796  
00001338  4DF9 00008C21                    797  		lea		data,a6
0000133E  4EB9 00001A60                    798  		jsr		create
00001344                                   799  
00001344  46FC 2000                        800  		move.w		#$2000,sr	; turn interrupts back on
00001348  41F9 000080E7                    801  		lea		clk_on,a0
0000134E  10BC 0001                        802  		move.b		#1,(a0)		; turn clock  back on
00001352                                   803  
00001352  41F9 000080DC                    804  		lea		cclock,a0
00001358  43F9 00008A4E                    805  		lea		prevsecs,a1
0000135E  1290                             806  		move.b		(a0),(a1)		; set previous seconds
00001360  6000 00E8                        807  		bra		t_lblab
00001364                                   808  	************************************************************************************
00001364                                   809  	* The actual game....
00001364                                   810  tetrismn:	
00001364                                   811  	* check the drop by comparing seconds of the clock
00001364  46FC 2000                        812  		move.w		#$2000,sr	; turn them on
00001368  4E71                             813  		nop				; if an interrupt, make sure it has time
0000136A  46FC 2700                        814  		move.w		#$2700,sr	; turn them off
0000136E                                   815  
0000136E  41F9 0000801B                    816  		lea		atr_off,a0
00001374  4EB9 00001D98                    817  		jsr		prt_str
0000137A                                   818  
0000137A  43F9 00008A4E                    819  		lea		prevsecs,a1
00001380  41F9 000080DC                    820  		lea		cclock,a0
00001386  1010                             821  		move.b		(a0),d0
00001388  1211                             822  		move.b		(a1),d1
0000138A  B200                             823  		cmp.b		d0,d1
0000138C  6700 000E                        824  		beq		t_lblaa		* no drop
00001390  4EB9 00001702                    825  		jsr		drop_i		* drop the item
00001396  1280                             826  		move.b		d0,(a1)		; set the new previous seconds
00001398  6000 00B0                        827  		bra		t_lblab		* go to the drawing section
0000139C                                   828  
0000139C  4E41                             829  t_lblaa:	trap		#1			; check for input
0000139E  B03C 0000                        830  		cmp.b		#0,d0
000013A2  67C0                             831  		beq		tetrismn
000013A4  4E42                             832  		trap		#2
000013A6                                   833  
000013A6  1200                             834  		move.b		d0,d1
000013A8  103C 0008                        835  		move.b		#8,d0
000013AC  4E43                             836  		trap		#3
000013AE  103C 0020                        837  		move.b		#' ',d0
000013B2  4E43                             838  		trap		#3
000013B4  103C 0008                        839  		move.b		#8,d0
000013B8  4E43                             840  		trap		#3
000013BA                                   841  		
000013BA  B23C 002F                        842  		cmp.b		#'/',d1		; check for <down> keypress
000013BE  6700 0048                        843  		beq		t_lblac
000013C2  B23C 002C                        844  		cmp.b		#',',d1		; check for move left
000013C6  6700 004A                        845  		beq		t_lblad		; move left
000013CA  B23C 002E                        846  		cmp.b		#'.',d1		; check for move right
000013CE  6700 0050                        847  		beq		t_lblae		; move right
000013D2  B23C 007A                        848  		cmp.b		#'z',d1
000013D6  6700 0056                        849  		beq		t_lblaf		; rotate left
000013DA  B23C 0078                        850  		cmp.b		#'x',d1
000013DE  6700 005C                        851  		beq		t_lblag		; rotate right
000013E2  B23C 001B                        852  		cmp.b		#27,d1
000013E6  6700 0066                        853  		beq		tetrsOvr		; leave
000013EA  B23C 0031                        854  		cmp.b		#'1',d1
000013EE  6700 005E                        855  		beq		tetrsOvr
000013F2                                   856  
000013F2  B23C 0070                        857  		cmp.b		#'p',d1
000013F6  6700 0006                        858  		beq		spd_up
000013FA                                   859  
000013FA  6000 FF68                        860  		bra		tetrismn
000013FE                                   861  
000013FE                                   862  spd_up:	* increase the speed of the game
000013FE  1038 0009                        863  		move.b		9,d0
00001402  4E47                             864  		trap		#7
00001404  6000 FF5E                        865  		bra		tetrismn
00001408                                   866  
00001408                                   867  
00001408                                   868  t_lblac:	* down keypress
00001408  4EB9 00001702                    869  		jsr		drop_i
0000140E  6000 FF54                        870  		bra		tetrismn
00001412                                   871  
00001412                                   872  t_lblad:	* move left
00001412  103C 00FF                        873  		move.b	#-1,d0
00001416  4EB9 000016B6                    874  		jsr		move_i
0000141C  6000 FF46                        875  		bra		tetrismn
00001420                                   876  
00001420                                   877  t_lblae:	* move right
00001420  103C 0001                        878  		move.b	#1,d0
00001424  4EB9 000016B6                    879  		jsr		move_i
0000142A  6000 FF38                        880  		bra		tetrismn
0000142E                                   881  
0000142E                                   882  t_lblaf:	* rotate left
0000142E  103C 0001                        883  		move.b	#1,d0
00001432  4EB9 000015D6                    884  		jsr		rotate_i
00001438  6000 FF2A                        885  		bra		tetrismn
0000143C                                   886  
0000143C                                   887  t_lblag:	* rotate right
0000143C  103C 00FF                        888  		move.b	#-1,d0
00001440  4EB9 000015D6                    889  		jsr		rotate_i
00001446  6000 FF1C                        890  		bra		tetrismn
0000144A                                   891  
0000144A                                   892  t_lblab:	* this label is left over from a bad looping decision, left here just incase I didn't update everything
0000144A  6000 FF18                        893  		bra		tetrismn	* keep looping
0000144E                                   894  
0000144E                                   895  	************************************************************************************
0000144E                                   896  	* Shutdown, restore the values of the clock program, reverse most things from the setup
0000144E                                   897  tetrsOvr:
0000144E  46FC 2700                        898  		move.w		#$2700,sr		; make sure off
00001452                                   899  
00001452  41F9 000080E7                    900  		lea		clk_on,a0
00001458  10BC 0000                        901  		move.b		#0,(a0)				; turn off the clock
0000145C                                   902  
0000145C  41F9 00008AC2                    903  		lea		Msgaab,a0			; erase the entire screen
00001462  4EB9 00001D98                    904  		jsr		prt_str
00001468                                   905  
00001468                                   906  * fill half the screen with black again		
00001468  41F9 0000805C                    907  		lea		xy_init,a0
0000146E  4EB9 00001D98                    908  		jsr		prt_str
00001474  41F9 00008AC7                    909  		lea		newattr,a0
0000147A  4EB9 00001D98                    910  		jsr		prt_str
00001480  4281                             911  		clr.l		d1
00001482                                   912  
00001482  103C 0020                        913  		move.b		#' ',d0
00001486  323C 03C0                        914  		move.w		#960,d1		; 80*12=960 white spaces
0000148A  6000 0004                        915  		bra		spTsta
0000148E                                   916  
0000148E  4E43                             917  spLpa:		trap		#3
00001490  51C9 FFFC                        918  spTsta:		dbra		d1,spLpa
00001494                                   919  
00001494  41F9 00008021                    920  		lea		save,a0
0000149A  4EB9 00001D98                    921  		jsr		prt_str
000014A0                                   922  
000014A0  41F9 0000801B                    923  		lea		atr_off,a0
000014A6  4EB9 00001D98                    924  		jsr		prt_str
000014AC                                   925  
000014AC  43F9 00008A4F                    926  		lea		setscroll,a1
000014B2  45F9 00008000                    927  		lea		scroll_msg,a2
000014B8  4EB9 00001ADA                    928  		jsr		switch			; change the scroll pattern
000014BE  41F9 00008000                    929  		lea		scroll_msg,a0
000014C4  4EB9 00001D98                    930  		jsr		prt_str
000014CA                                   931  
000014CA  43F9 00008A5C                    932  		lea		nmovC,a1			; clock positioning
000014D0  45F9 00008027                    933  		lea		movec,a2			; addresses of the move messages
000014D6  4EB9 00001ADA                    934  		jsr		switch
000014DC  43F9 00008A68                    935  		lea		nmovA,a1			; alarm positioning
000014E2  45F9 00008032                    936  		lea		movalm,a2
000014E8  4EB9 00001ADA                    937  		jsr		switch
000014EE  43F9 00008A74                    938  		lea		nmovT,a1			; timer positioning
000014F4  45F9 0000803D                    939  		lea		movTmr,a2
000014FA  4EB9 00001ADA                    940  		jsr		switch
00001500  43F9 00008A80                    941  		lea		nmovMsg,a1			; Msg positioning
00001506  45F9 00008048                    942  		lea		movMsg,a2
0000150C  4EB9 00001ADA                    943  		jsr		switch
00001512                                   944  
00001512  43F9 0000800E                    945  		lea		atr_on,a1			; new attributes
00001518  45F9 00008AC7                    946  		lea		newattr,a2
0000151E  4EB9 00001ADA                    947  		jsr		switch
00001524                                   948  
00001524  43F9 0000801B                    949  		lea		atr_off,a1
0000152A  45F9 00008AD3                    950  		lea		new_off,a2
00001530  4EB9 00001ADA                    951  		jsr		switch
00001536                                   952  
00001536  41F9 0000800E                    953  		lea		atr_on,a0
0000153C  4EB9 00001D98                    954  		jsr		prt_str
00001542                                   955  
00001542  43F9 00008027                    956  		lea		movec,a1
00001548  4EB9 00001D98                    957  		jsr		prt_str
0000154E  45F9 00008097                    958  		lea		sclock,a2
00001554  4EB9 00001D98                    959  		jsr		prt_str
0000155A                                   960  
0000155A  43F9 000080E6                    961  		lea		alrm_on,a1
00001560  1011                             962  		move.b		(a1),d0
00001562  B03C 0000                        963  		cmp.b		#0,d0
00001566  6700 001A                        964  		beq		lbl_av
0000156A  41F9 00008032                    965  		lea		movalm,a0
00001570  4EB9 00001D98                    966  		jsr		prt_str
00001576  41F9 000080C5                    967  		lea		salarm,a0
0000157C  4EB9 00001D98                    968  		jsr		prt_str
00001582                                   969  
00001582  41F9 000080E5                    970  lbl_av:		lea		tmr_on,a0
00001588  1010                             971  		move.b		(a0),d0
0000158A  B03C 0000                        972  		cmp.b		#0,d0
0000158E  6700 001A                        973  		beq		lbl_ax
00001592  41F9 0000803D                    974  		lea		movtmr,a0
00001598  4EB9 00001D98                    975  		jsr		prt_str
0000159E  41F9 000080AE                    976  		lea		stimer,a0
000015A4  4EB9 00001D98                    977  		jsr		prt_str
000015AA                                   978  
000015AA                                   979  	* everything is back to what it should be
000015AA  41F9 0000801B                    980  lbl_ax:		lea		atr_off,a0
000015B0  4EB9 00001D98                    981  		jsr		prt_str
000015B6  41F9 00008053                    982  		lea		gfx,a0
000015BC  4EB9 00001D98                    983  		jsr		prt_str
000015C2  46FC 2000                        984  		move.w		#$2000,sr		; timer back on
000015C6  41F9 000080E7                    985  		lea		clk_on,a0			; turn back on the clock
000015CC  10BC 0001                        986  		move.b		#1,(a0)
000015D0  4CDF FFFF                        987  		movem.l		(sp)+,d0-d7/a0-a7		; restore the registers
000015D4  4E75                             988  		rts
000015D6                                   989  ***************************************************************************************
000015D6                                   990  *	rotate_i	- rotate the item to the left or right
000015D6                                   991  *	Input:	d0 - the direction.
000015D6                                   992  *		(-1) -> right
000015D6                                   993  *		1    -> left
000015D6                                   994  *	Output: If the rotation can be done, it is, otherwise, it just returns
000015D6                                   995  ***************************************************************************************
000015D6  48E7 F0C0                        996  rotate_i:	movem.l		d0/d1/d2/d3/a0/a1,-(sp)
000015DA                                   997  
000015DA  41F9 00008A39                    998  		lea		i_pos,a0
000015E0  1610                             999  		move.b		(a0),d3
000015E2  D600                            1000  		add.b		d0,d3
000015E4                                  1001  
000015E4  B63C 0000                       1002  		cmp.b		#0,d3
000015E8  6E00 0006                       1003  		bgt		rLblaa
000015EC  363C 0004                       1004  		move.w		#4,d3
000015F0  B63C 0005                       1005  rLblaa:		cmp.b		#5,d3
000015F4  6D00 0006                       1006  		blt		rLblbb
000015F8  363C 0001                       1007  		move.w		#1,d3
000015FC  41F9 00008A4C                   1008  rLblbb:		lea		t_xy,a0
00001602  1083                            1009  		move.b		d3,(a0)		; temp save of the new position
00001604  41F9 00008A3A                   1010  		lea		i_xy,a0
0000160A  1218                            1011  		move.b		(a0)+,d1
0000160C  1418                            1012  		move.b		(a0)+,d2
0000160E  41F9 00008A38                   1013  		lea		i_type,a0
00001614  1010                            1014  		move.b		(a0),d0
00001616  4EB9 00001800                   1015  		jsr		plot_i		; plot the item into t_pts
0000161C                                  1016  
0000161C  41F9 00008A44                   1017  		lea		t_pts,a0
00001622  363C 0003                       1018  		move.w		#3,d3
00001626                                  1019  
00001626  1218                            1020  rLblcc:		move.b		(a0)+,d1
00001628  1418                            1021  		move.b		(a0)+,d2
0000162A  4EB9 00001B6A                   1022  		jsr		readxy
00001630  B03C 0000                       1023  		cmp.b		#0,d0
00001634  6D00 0022                       1024  		blt		rLbldd
00001638  B03C 0023                       1025  		cmp.b		#'#',d0
0000163C  6700 001A                       1026  		beq		rLbldd
00001640  51CB FFE4                       1027  		dbra		d3,rLblcc
00001644                                  1028  	* valid rotation
00001644  41F9 00008A4C                   1029  		lea		t_xy,a0
0000164A  43F9 00008A39                   1030  		lea		i_pos,a1
00001650  1290                            1031  		move.b		(a0),(a1)		; save the position
00001652                                  1032  *		lea		i_xy,a0
00001652                                  1033  *		lea		t_xy,a1
00001652                                  1034  *		move.w		(a0),(a1)		; set the same xy so draw_i doesn't mess things up
00001652  4EB9 0000165E                   1035  		jsr		draw_i		; draw and move points from t_pts to i_pts
00001658                                  1036  
00001658  4CDF 030F                       1037  rLbldd:		movem.l		(sp)+,d0/d1/d2/d3/a0/a1
0000165C  4E75                            1038  		rts
0000165E                                  1039  
0000165E                                  1040  ********************************************************************************
0000165E                                  1041  *	draw_i - given the point in i_pts and t_pts, this subroutine deletes
0000165E                                  1042  *		 the item from i_pts on the field, and draws to the t_pts
0000165E                                  1043  *	Input: None
0000165E                                  1044  *	Output: None
0000165E                                  1045  ********************************************************************************
0000165E  48E7 F0C0                       1046  draw_i:		movem.l		d0/d1/d2/d3/a0/a1,-(sp)
00001662                                  1047  	* delete the old item
00001662  363C 0003                       1048  		move.w		#3,d3
00001666  41F9 00008A3C                   1049  		lea		i_pts,a0
0000166C                                  1050  		
0000166C  1218                            1051  lblDraw:	move.b		(a0)+,d1
0000166E  1418                            1052  		move.b		(a0)+,d2
00001670  103C 0020                       1053  		move.b		#' ',d0
00001674  4EB9 00001BB2                   1054  		jsr		writexy
0000167A  51CB FFF0                       1055  		dbra		d3,lblDraw
0000167E                                  1056  
0000167E  363C 0003                       1057  		move.w		#3,d3
00001682  43F9 00008A44                   1058  		lea		t_pts,a1
00001688                                  1059  	* draw the new item
00001688  1219                            1060  lbl2Draw:	move.b		(a1)+,d1
0000168A  1419                            1061  		move.b		(a1)+,d2
0000168C  103C 0040                       1062  		move.b		#'@',d0
00001690  4EB9 00001BB2                   1063  		jsr		writexy
00001696  51CB FFF0                       1064  		dbra		d3,lbl2Draw
0000169A                                  1065  
0000169A  363C 0003                       1066  		move.w		#3,d3
0000169E  41F9 00008A3C                   1067  		lea		i_pts,a0
000016A4  43F9 00008A44                   1068  		lea		t_pts,a1
000016AA  30D9                            1069  lbl3Draw:	move.w		(a1)+,(a0)+	; move the points from temp to the set points
000016AC  51CB FFFC                       1070  		dbra		d3,lbl3Draw
000016B0                                  1071  
000016B0  4CDF 030F                       1072  		movem.l		(sp)+,d0/d1/d2/d3/a0/a1
000016B4  4E75                            1073  		rts
000016B6                                  1074  
000016B6                                  1075  ********************************************************************************
000016B6                                  1076  *	move_i - move the item ( if possible )
000016B6                                  1077  *	Input:
000016B6                                  1078  *		d0:	1 - move to the right, -1 - move left
000016B6                                  1079  *	Output: If the piece can be moved, it is updated in the field
000016B6                                  1080  *		  Otherwise, nothing happens
000016B6                                  1081  ********************************************************************************
000016B6  48E7 F8C0                       1082  move_i:		movem.l		d0/d1/d2/d3/d4/a0/a1,-(sp)	
000016BA  1800                            1083  		move.b		d0,d4		; save the move for later
000016BC                                  1084  
000016BC                                  1085  	* set all of the new points as they are updated
000016BC  363C 0003                       1086  		move.w		#3,d3
000016C0  41F9 00008A3C                   1087  		lea		i_pts,a0
000016C6  43F9 00008A44                   1088  		lea		t_pts,a1
000016CC                                  1089  
000016CC  1218                            1090  lbl_jk:		move.b		(a0)+,d1
000016CE  1418                            1091  		move.b		(a0)+,d2
000016D0  D204                            1092  		add.b		d4,d1		; update due to the move
000016D2  12C1                            1093  		move.b		d1,(a1)+
000016D4  12C2                            1094  		move.b		d2,(a1)+	; save in t_pts
000016D6  4EB9 00001B6A                   1095  		jsr		readxy		; read the xy from the field
000016DC  B03C 0000                       1096  		cmp.b		#0,d0
000016E0  6D00 001A                       1097  		blt		movDone
000016E4  B03C 0023                       1098  		cmp.b		#'#',d0
000016E8  6700 0012                       1099  		beq		movDone
000016EC  51CB FFDE                       1100  		dbra		d3,lbl_jk
000016F0                                  1101  	* if it reached this point, than it's valid,.. update the xy coordinate in i_xy
000016F0  41F9 00008A3A                   1102  		lea		i_xy,a0
000016F6  D910                            1103  		add.b		d4,(a0)	; update the x value
000016F8                                  1104  		
000016F8                                  1105  	* the old item needs erased, and the new one drawn
000016F8  4EB8 165E                       1106  		jsr		draw_i
000016FC                                  1107  
000016FC  4CDF 031F                       1108  movDone:	movem.l		(sp)+,d0/d1/d2/d3/d4/a0/a1
00001700  4E75                            1109  		rts
00001702                                  1110  
00001702                                  1111  ********************************************************************************
00001702                                  1112  *	drop_i	drop the item, (due to the time being up)
00001702                                  1113  *	Input:	None, assumes a drop of 1 in the field
00001702                                  1114  *	Output: If the drop is successful (doesn't land on another) then it
00001702                                  1115  *		returns like normal.  If it does land, than it	
00001702                                  1116  ********************************************************************************
00001702  48E7 F8C0                       1117  drop_i:		movem.l		d0/d1/d2/d3/d4/a0/a1,-(sp)
00001706  363C 0003                       1118  		move.w		#3,d3
0000170A  41F9 00008A3C                   1119  		lea		i_pts,a0
00001710  43F9 00008A44                   1120  		lea		t_pts,a1
00001716                                  1121  
00001716  1218                            1122  lblttt:		move.b		(a0)+,d1	; get x
00001718  1418                            1123  		move.b		(a0)+,d2	; get y
0000171A  5202                            1124  		add.b		#1,d2		; drop
0000171C  12C1                            1125  		move.b		d1,(a1)+
0000171E  12C2                            1126  		move.b		d2,(a1)+	; save points in t_xy
00001720  4EB9 00001B6A                   1127  		jsr		readxy		; test xy
00001726  B03C 0000                       1128  		cmp.b		#0,d0
0000172A  6D00 0024                       1129  		blt		lblhit
0000172E  B03C 0023                       1130  		cmp.b		#'#',d0
00001732  6700 001C                       1131  		beq		lblhit
00001736  51CB FFDE                       1132  		dbra		d3,lblttt
0000173A                                  1133  
0000173A                                  1134  	* if it gets to this point, than it is valid drop, no hit.
0000173A  4EB8 165E                       1135  		jsr		draw_i
0000173E  41F9 00008A3A                   1136  		lea		i_xy,a0
00001744  3210                            1137  		move.w		(a0),d1
00001746  5241                            1138  		add.w		#$0001,d1
00001748  3081                            1139  		move.w		d1,(a0)		; save new y coordinate
0000174A                                  1140  
0000174A  4CDF 031F                       1141  lblsss:		movem.l		(sp)+,d0/d1/d2/d3/d4/a0/a1
0000174E  4E75                            1142  		rts
00001750                                  1143  
00001750                                  1144  lblhit:	* the item hit something while falling, so make it land
00001750  363C 0003                       1145  		move.w		#3,d3
00001754  41F9 00008A3C                   1146  		lea		i_pts,a0
0000175A  103C 0023                       1147  		move.b		#'#',d0		; set what to draw
0000175E  1218                            1148  lblqqq:		move.b		(a0)+,d1
00001760  1418                            1149  		move.b		(a0)+,d2
00001762  4EB9 00001BB2                   1150  		jsr		writexy
00001768  51CB FFF4                       1151  		dbra		d3,lblqqq
0000176C                                  1152  	* before a new item is created, check all of the lines that the dropped
0000176C                                  1153  	* item landed in.  Only these four lines (at max) need to be checked for
0000176C                                  1154  	* a complete line.
0000176C  41F9 000080E7                   1155  		lea		clk_on,a0
00001772  10BC 0000                       1156  		move.b		#0,(a0)
00001776  46FC 2000                       1157  		move.w		#$2000,sr
0000177A                                  1158  		
0000177A  363C 0003                       1159  		move.w		#3,d3		; check all four lines
0000177E  41F9 00008A3C                   1160  		lea		i_pts,a0
00001784                                  1161  
00001784  343C 0013                       1162  		move.w		#19,d2
00001788  323C 0009                       1163  lblrsr:		move.w		#9,d1		; set another counter
0000178C  4EB9 00001B6A                   1164  lbl_wrs:	jsr		readxy		; check that coordinate
00001792  B03C 0023                       1165  		cmp.b		#'#',d0
00001796  6600 000E                       1166  		bne		notLine
0000179A  51C9 FFF0                       1167  		dbra		d1,lbl_wrs
0000179E                                  1168  	* if it reaches these lines, than it found a complete line, have to update it
0000179E  4EB9 000017C0                   1169  		jsr		wipe
000017A4  5202                            1170  		add.b		#1,d2		; have to recheck the same line
000017A6                                  1171  
000017A6  51CA FFE0                       1172  notLine:	dbra		d2,lblrsr
000017AA  41F9 000080E7                   1173  		lea		clk_on,a0
000017B0  10BC 0001                       1174  		move.b		#1,(a0)
000017B4  46FC 2700                       1175  		move.w		#$2700,sr	; turn timer back on
000017B8                                  1176  
000017B8                                  1177  	* if any comlete lines, they are cleared out, we can create a new piece and continue
000017B8                                  1178  
000017B8  4EB9 00001A60                   1179  		jsr		create		; create a new item to drop
000017BE  608A                            1180  		bra		lblsss
000017C0                                  1181  
000017C0                                  1182  ********************************************************************************
000017C0                                  1183  *	wipe	called when a complete line is found, and so the lines above need moved down
000017C0                                  1184  *	Input: d2 - the y value of the line that was found to be complete
000017C0                                  1185  ********************************************************************************
000017C0  48E7 E000                       1186  wipe:		movem.l		d0/d1/d2,-(sp)
000017C4  C47C 00FF                       1187  		and.w		#$00ff,d2	; make sure word value
000017C8  323C 0009                       1188  w_lbl_w:	move.w		#9,d1
000017CC  5302                            1189  w_lbla:		sub.b		#1,d2	; go to the line above
000017CE  B43C 0000                       1190  		cmp.b		#0,d2
000017D2  6D00 0026                       1191  		blt		w_lblz
000017D6  4EB9 00001B6A                   1192  		jsr		readxy	; read from the field
000017DC  B03C 0023                       1193  		cmp.b		#'#',d0
000017E0  6600 0018                       1194  		bne		w_lblz
000017E4                                  1195  
000017E4  5202                            1196  w_lblx:		add.b		#1,d2
000017E6  4EB9 00001BB2                   1197  		jsr		writexy
000017EC                                  1198  
000017EC  51C9 FFDE                       1199  		dbra		d1,w_lbla	; go thru the row
000017F0                                  1200  
000017F0  51CA FFD6                       1201  		dbra		d2,w_lbl_w	; for each column
000017F4                                  1202  
000017F4  4CDF 0007                       1203  		movem.l		(sp)+,d0/d1/d2
000017F8  4E75                            1204  		rts
000017FA                                  1205  
000017FA  103C 0020                       1206  w_lblz:		move.b		#' ',d0
000017FE  60E4                            1207  		bra		w_lblx
00001800                                  1208  
00001800                                  1209  ********************************************************************************
00001800                                  1210  *	plot_i	plot the item into x,y coordinates for each 'block'
00001800                                  1211  *	Input:		d0 - type of block
00001800                                  1212  *			d1 - x of the item
00001800                                  1213  *			d2 - y of the item
00001800                                  1214  *			d3 - position (rotation)
00001800                                  1215  *	Output:	Given the above information, the piece is plotted into four
00001800                                  1216  *			sets of (x,y) which is stored in memory at 't_pts'
00001800                                  1217  ********************************************************************************
00001800  48E7 F880                       1218  plot_i:		movem.l		d0/d1/d2/d3/d4/a0,-(sp)
00001804  41F9 00008A44                   1219  		lea		t_pts,a0		; get address to store the points
0000180A                                  1220  
0000180A                                  1221  	* switch by the type value
0000180A  B03C 0001                       1222  		cmp.b		#1,d0
0000180E  6700 008E                       1223  		beq		pBlock
00001812  B03C 0002                       1224  		cmp.b		#2,d0
00001816  6700 00A0                       1225  		beq		pLong
0000181A  B03C 0003                       1226  		cmp.b		#3,d0
0000181E  6700 00DA                       1227  		beq		pS
00001822  B03C 0004                       1228  		cmp.b		#4,d0
00001826  6700 0108                       1229  		beq		pRevS
0000182A  B03C 0005                       1230  		cmp.b		#5,d0
0000182E  6700 016C                       1231  		beq		pL
00001832  B03C 0006                       1232  		cmp.b		#6,d0
00001836  6700 01C4                       1233  		beq		pRevL
0000183A                                  1234  * T shaped item  ==========================================================================
0000183A                                  1235  	* #7 is a T shaped, and also the default
0000183A  1801                            1236  		move.b		d1,d4
0000183C  E14C                            1237  		lsl.w		#8,d4
0000183E  1802                            1238  		move.b		d2,d4
00001840  0644 0101                       1239  		add.w		#$0101,d4
00001844  30C4                            1240  		move.w		d4,(a0)+	; set middle point
00001846  0803 0000                       1241  		btst		#0,d3
0000184A  6700 002E                       1242  		beq		pTlblaz		; if left or right
0000184E  1801                            1243  		move.b		d1,d4
00001850  E14C                            1244  		lsl.w		#8,d4
00001852  1802                            1245  		move.b		d2,d4
00001854  5244                            1246  		add.w		#$0001,d4
00001856  30C4                            1247  		move.w		d4,(a0)+
00001858  0644 0200                       1248  		add.w		#$0200,d4
0000185C  30C4                            1249  		move.w		d4,(a0)+
0000185E  B63C 0001                       1250  		cmp.b		#1,d3
00001862  6700 000C                       1251  		beq		pTlblax
00001866  0444 0101                       1252  		sub.w		#$0101,d4
0000186A  30C4                            1253  		move.w		d4,(a0)+
0000186C  6000 01EC                       1254  		bra		pDone
00001870  0644 FF01                       1255  pTlblax:	add.w		#$ff01,d4
00001874  30C4                            1256  		move.w		d4,(a0)+
00001876  6000 01E2                       1257  		bra		pDone
0000187A                                  1258  
0000187A                                  1259  pTlblaz:   * left or right positioned
0000187A  5344                            1260  		sub.w		#$0001,d4
0000187C  30C4                            1261  		move.w		d4,(a0)+
0000187E  5444                            1262  		add.w		#$0002,d4
00001880  30C4                            1263  		move.w		d4,(a0)+
00001882  B63C 0002                       1264  		cmp.b		#02,d3
00001886  6700 000C                       1265  		beq		pTlblav
0000188A  0444 0101                       1266  		sub.w		#$0101,d4
0000188E  30C4                            1267  		move.w		d4,(a0)+
00001890  6000 01C8                       1268  		bra		pDone
00001894  0644 00FF                       1269  pTlblav:	add.w		#$00ff,d4
00001898  30C4                            1270  		move.w		d4,(a0)+
0000189A  6000 01BE                       1271  		bra		pDone
0000189E                                  1272  
0000189E                                  1273  * block item, all the same! ===================================================================
0000189E  1801                            1274  pBlock:		move.b		d1,d4
000018A0  E14C                            1275  		lsl.w		#8,d4
000018A2  1802                            1276  		move.b		d2,d4		; set x,y
000018A4  30C4                            1277  		move.w		d4,(a0)+
000018A6  5204                            1278  		add.b		#1,d4
000018A8  30C4                            1279  		move.w		d4,(a0)+
000018AA  0644 0100                       1280  		add.w		#$0100,d4
000018AE  30C4                            1281  		move.w		d4,(a0)+
000018B0  5304                            1282  		sub.b		#1,d4
000018B2  30C4                            1283  		move.w		d4,(a0)+
000018B4  6000 01A4                       1284  		bra		pDone
000018B8                                  1285  
000018B8                                  1286  * long item, only two positions to plot ======================================================
000018B8  0803 0000                       1287  pLong:		btst		#0,d3		; test position
000018BC  6700 001C                       1288  		beq		pLlbl
000018C0                                  1289  		* vertical
000018C0  1801                            1290  		move.b		d1,d4
000018C2  5204                            1291  		add.b		#1,d4
000018C4  E14C                            1292  		lsl.w		#8,d4
000018C6  1802                            1293  		move.b		d2,d4
000018C8  30C4                            1294  		move.w		d4,(a0)+
000018CA  5204                            1295  		add.b		#1,d4
000018CC  30C4                            1296  		move.w		d4,(a0)+
000018CE  5204                            1297  		add.b		#1,d4
000018D0  30C4                            1298  		move.w		d4,(a0)+
000018D2  5204                            1299  		add.b		#1,d4
000018D4  30C4                            1300  		move.w		d4,(a0)+
000018D6  6000 0182                       1301  		bra		pDone
000018DA                                  1302  pLlbl:	* positions 2 or 4, both the same, (horizontal)
000018DA  1801                            1303  		move.b		d1,d4
000018DC  E14C                            1304  		lsl.w		#8,d4
000018DE  1802                            1305  		move.b		d2,d4
000018E0  5404                            1306  		add.b		#2,d4
000018E2  30C4                            1307  		move.w		d4,(a0)+
000018E4  0644 0100                       1308  		add.w		#$0100,d4
000018E8  30C4                            1309  		move.w		d4,(a0)+
000018EA  0644 0100                       1310  		add.w		#$0100,d4
000018EE  30C4                            1311  		move.w		d4,(a0)+
000018F0  0644 0100                       1312  		add.w		#$0100,d4
000018F4  30C4                            1313  		move.w		d4,(a0)+
000018F6  6000 0162                       1314  		bra		pDone
000018FA                                  1315  
000018FA                                  1316  * S shaped item, again only two postions ======================================================
000018FA                                  1317  pS:
000018FA  1801                            1318  		move.b		d1,d4
000018FC  5204                            1319  		add.b		#1,d4
000018FE  E14C                            1320  		lsl.w		#8,d4
00001900  1802                            1321  		move.b		d2,d4
00001902  5204                            1322  		add.b		#1,d4
00001904  30C4                            1323  		move.w		d4,(a0)+
00001906  5204                            1324  		add.b		#1,d4
00001908  30C4                            1325  		move.w		d4,(a0)+
0000190A  0803 0000                       1326  		btst		#0,d3		; test the position
0000190E  6700 0012                       1327  		beq		pSlbla
00001912  0444 0100                       1328  		sub.w		#$0100,d4
00001916  30C4                            1329  		move.w		d4,(a0)+
00001918  0644 01FF                       1330  		add.w		#$01ff,d4
0000191C  30C4                            1331  		move.w		d4,(a0)+
0000191E  6000 013A                       1332  		bra		pDone
00001922  0444 0101                       1333  pSlbla:		sub.w		#$0101,d4
00001926  30C4                            1334  		move.w		d4,(a0)+
00001928  5304                            1335  		sub.b		#1,d4
0000192A  30C4                            1336  		move.w		d4,(a0)+
0000192C  6000 012C                       1337  		bra		pDone
00001930                                  1338  
00001930                                  1339  *  Reversed S, two positions to draw ==========================================================
00001930                                  1340  pRevS:
00001930                                  1341  
00001930  1801                            1342  		move.b		d1,d4
00001932  5204                            1343  		add.b		#1,d4
00001934  E14C                            1344  		lsl.w		#8,d4
00001936  1802                            1345  		move.b		d2,d4
00001938  5204                            1346  		add.b		#1,d4
0000193A  30C4                            1347  		move.w		d4,(a0)+
0000193C  5204                            1348  		add.b		#1,d4
0000193E  30C4                            1349  		move.w		d4,(a0)+
00001940  0803 0000                       1350  		btst		#0,d3		; test the position
00001944  6700 0012                       1351  		beq		pRevSz
00001948  0644 0100                       1352  		add.w		#$0100,d4
0000194C  30C4                            1353  		move.w		d4,(a0)+
0000194E  0444 0201                       1354  		sub.w		#$0201,d4
00001952  30C4                            1355  		move.w		d4,(a0)+
00001954  6000 0104                       1356  		bra		pDone
00001958                                  1357  
00001958  0644 00FF                       1358  pRevSz:		add.w		#$00ff,d4
0000195C  30C4                            1359  		move.w		d4,(a0)+
0000195E  5304                            1360  		sub.b		#1,d4
00001960  30C4                            1361  		move.w		d4,(a0)+
00001962  6000 00F6                       1362  		bra		pDone
00001966                                  1363  
00001966                                  1364  * ignore the lines below for now
00001966  1801                            1365  		move.b		d1,d4
00001968  E14C                            1366  		lsl.w		#8,d4
0000196A  1802                            1367  		move.b		d2,d4
0000196C  0644 0065                       1368  		add.w		#0101,d4
00001970  30C4                            1369  		move.w		d4,(a0)+
00001972  5204                            1370  		add.b		#1,d4
00001974  30C4                            1371  		move.w		d4,(a0)+
00001976  0803 0000                       1372  		btst		#0,d3
0000197A  6700 0012                       1373  		beq		pRevSb
0000197E  0444 0101                       1374  		sub.w		#$0101,d4
00001982  30C4                            1375  		move.w		d4,(a0)+
00001984  0644 0201                       1376  		add.w		#$0201,d4
00001988  30C4                            1377  		move.w		d4,(a0)+
0000198A  6000 00CE                       1378  		bra		pDone
0000198E                                  1379  
0000198E  0644 00FF                       1380  pRevSb:		add.w		#$00ff,d4
00001992  30C4                            1381  		move.w		d4,(a0)+
00001994  5304                            1382  		sub.b		#1,d4
00001996  30C4                            1383  		move.w		d4,(a0)+
00001998  6000 00C0                       1384  		bra		pDone
0000199C                                  1385  
0000199C                                  1386  *  L shaped, have to draw all four ============================================================
0000199C  1801                            1387  pL:		move.b		d1,d4
0000199E  E14C                            1388  		lsl.w		#8,d4
000019A0  1802                            1389  		move.b		d2,d4
000019A2  0644 0101                       1390  		add.w		#$0101,d4
000019A6  30C4                            1391  		move.w		d4,(a0)+
000019A8  0803 0000                       1392  		btst		#0,d3
000019AC  6700 0026                       1393  		beq		pLlbla
000019B0  5304                            1394  		sub.b		#1,d4
000019B2  30C4                            1395  		move.w		d4,(a0)+
000019B4  5404                            1396  		add.b		#2,d4
000019B6  30C4                            1397  		move.w		d4,(a0)+
000019B8  B63C 0003                       1398  		cmp.b		#3,d3
000019BC  6700 000C                       1399  		beq		pLlblb
000019C0  0644 0100                       1400  		add.w		#$0100,d4
000019C4  30C4                            1401  		move.w		d4,(a0)+
000019C6  6000 0092                       1402  		bra		pDone
000019CA  0444 0102                       1403  pLlblb:		sub.w		#$0102,d4
000019CE  30C4                            1404  		move.w		d4,(a0)+
000019D0  6000 0088                       1405  		bra		pDone
000019D4                                  1406  
000019D4  0444 0100                       1407  pLlbla:		sub.w		#$0100,d4
000019D8  30C4                            1408  		move.w		d4,(a0)+
000019DA  0644 0200                       1409  		add.w		#$0200,d4
000019DE  30C4                            1410  		move.w		d4,(a0)+
000019E0  B63C 0004                       1411  		cmp.b		#4,d3		; check the type
000019E4  6700 000E                       1412  		beq		pLlblc
000019E8  0444 0200                       1413  		sub.w		#$0200,d4
000019EC  5204                            1414  		add.b		#1,d4
000019EE  30C4                            1415  		move.w		d4,(a0)+
000019F0  6000 0068                       1416  		bra		pDone
000019F4                                  1417  
000019F4  5344                            1418  pLlblc:		sub.w		#1,d4
000019F6  30C4                            1419  		move.w		d4,(a0)+
000019F8  6000 0060                       1420  		bra		pDone
000019FC                                  1421  
000019FC                                  1422  * Reversed L, again all 4 need drawn ==========================================================
000019FC  1801                            1423  pRevL:		move.b		d1,d4
000019FE  E14C                            1424  		lsl.w		#8,d4
00001A00  1802                            1425  		move.b		d2,d4
00001A02  0803 0000                       1426  		btst		#0,d3
00001A06  6700 002C                       1427  		beq		pRevLa
00001A0A  0644 0100                       1428  		add.w		#$0100,d4
00001A0E  30C4                            1429  		move.w		d4,(a0)+
00001A10  5204                            1430  		add.b		#1,d4
00001A12  30C4                            1431  		move.w		d4,(a0)+
00001A14  5204                            1432  		add.b		#1,d4
00001A16  30C4                            1433  		move.w		d4,(a0)+
00001A18  B63C 0001                       1434  		cmp.b		#1,d3
00001A1C  6700 000C                       1435  		beq		pRevLb
00001A20  0644 00FE                       1436  		add.w		#$00fe,d4
00001A24  30C4                            1437  		move.w		d4,(a0)+
00001A26  6000 0032                       1438  		bra		pDone
00001A2A                                  1439  
00001A2A  0444 0100                       1440  pRevLb:		sub.w		#$0100,d4
00001A2E  30C4                            1441  		move.w		d4,(a0)+
00001A30  6000 0028                       1442  		bra		pDone
00001A34                                  1443  
00001A34                                  1444  pRevLa:	* pos #2 and 4
00001A34  5204                            1445  		add.b		#1,d4
00001A36  30C4                            1446  		move.w		d4,(a0)+
00001A38  0644 0100                       1447  		add.w		#$0100,d4
00001A3C  30C4                            1448  		move.w		d4,(a0)+
00001A3E  0644 0100                       1449  		add.w		#$0100,d4
00001A42  30C4                            1450  		move.w		d4,(a0)+
00001A44  B63C 0002                       1451  		cmp.b		#2,d3
00001A48  6700 000A                       1452  		beq		pRevLc
00001A4C  5204                            1453  		add.b		#1,d4
00001A4E  30C4                            1454  		move.w		d4,(a0)+
00001A50  6000 0008                       1455  		bra		pDone
00001A54                                  1456  
00001A54  0444 0201                       1457  pRevLc:		sub.w		#$0201,d4
00001A58  30C4                            1458  		move.w		d4,(a0)+
00001A5A                                  1459  
00001A5A                                  1460  * All done ============================================================================
00001A5A  4CDF 011F                       1461  pDone:		movem.l	(sp)+,d0/d1/d2/d3/d4/a0
00001A5E  4E75                            1462  		rts
00001A60                                  1463  ********************************************************************************
00001A60                                  1464  *	create - create a new piece and store in memory
00001A60                                  1465  *		  This uses A6 as a 'static' varaiable which keeps track of where in
00001A60                                  1466  *		  the data the 'random' number is to loaded from
00001A60                                  1467  ********************************************************************************
00001A60  48E7 F0C0                       1468  create:		movem.l		d0/d1/d2/d3/a0/a1,-(sp)
00001A64  101E                            1469  		move.b		(a6)+,d0
00001A66  41F9 00008CFF                   1470  		lea		enddata,a0
00001A6C  BDC8                            1471  		cmpa.l		a0,a6
00001A6E  6F00 0008                       1472  		ble		lbl_af
00001A72  4DF9 00008C21                   1473  		lea		data,a6		; reset the 'random' pointer 
00001A78                                  1474  
00001A78  41F9 00008A38                   1475  lbl_af:		lea		i_type,a0
00001A7E  1080                            1476  		move.b		d0,(a0)		; set the type
00001A80  41F9 00008A39                   1477  		lea		i_pos,a0
00001A86  10BC 0001                       1478  		move.b		#1,(a0)		; set the position (rotation)
00001A8A  41F9 00008A3A                   1479  		lea		i_xy,a0
00001A90  30BC 0401                       1480  		move.w		#$0401,(a0)
00001A94                                  1481  
00001A94  41F9 00008A3C                   1482  		lea		i_pts,a0
00001A9A  30BC 0400                       1483  		move.w		#$0400,(a0)
00001A9E  163C 0001                       1484  		move.b		#1,d3
00001AA2  143C 0000                       1485  		move.b		#0,d2
00001AA6  123C 0004                       1486  		move.b		#4,d1
00001AAA  4EB8 1800                       1487  		jsr		plot_i		; plot the item
00001AAE                                  1488  
00001AAE  41F9 00008A3C                   1489  		lea		i_pts,a0
00001AB4  43F9 00008A44                   1490  		lea		t_pts,a1
00001ABA  363C 0003                       1491  		move.w		#3,d3
00001ABE  103C 0040                       1492  		move.b		#'@',d0
00001AC2                                  1493  
00001AC2  1219                            1494  lbl_gg:		move.b		(a1)+,d1
00001AC4  1419                            1495  		move.b		(a1)+,d2
00001AC6  10C1                            1496  		move.b		d1,(a0)+
00001AC8  10C2                            1497  		move.b		d2,(a0)+
00001ACA  4EB9 00001BB2                   1498  		jsr		writexy
00001AD0  51CB FFF0                       1499  		dbra		d3,lbl_gg
00001AD4                                  1500  
00001AD4  4CDF 030F                       1501  		movem.l		(sp)+,d0/d1/d2/d3/a0/a1
00001AD8  4E75                            1502  		rts
00001ADA                                  1503  ********************************************************************************
00001ADA                                  1504  *	switch - switch the move messages of a1 and a2
00001ADA                                  1505  *	Input - a1 - one of the addresses to switch
00001ADA                                  1506  *		  a2 - the other address
00001ADA                                  1507  ********************************************************************************
00001ADA  48E7 E060                       1508  switch:		movem.l		d0/d1/d2/a1/a2,-(sp)
00001ADE  303C 000A                       1509  		move.w		#10,d0
00001AE2  6000 000A                       1510  		bra		lbl_ac
00001AE6                                  1511  
00001AE6  1211                            1512  lbl_ab:		move.b		(a1),d1
00001AE8  1412                            1513  		move.b		(a2),d2
00001AEA  12C2                            1514  		move.b		d2,(a1)+
00001AEC  14C1                            1515  		move.b		d1,(a2)+
00001AEE                                  1516  
00001AEE  51C8 FFF6                       1517  lbl_ac:		dbra		d0,lbl_ab
00001AF2                                  1518  		
00001AF2  4CDF 0607                       1519  swDone:		movem.l		(sp)+,d0/d1/d2/a1/a2
00001AF6  4E75                            1520  		rts
00001AF8                                  1521  *******************************************************************************
00001AF8                                  1522  *	gotoxy - gotoxy on the screen
00001AF8                                  1523  *	Input: 	d1 - x
00001AF8                                  1524  *		d2 - y
00001AF8                                  1525  *******************************************************************************
00001AF8  48E7 E080                       1526  gotoxy:		movem.l		d0/d1/d2/a0,-(sp)
00001AFC  C2BC 000000FF                   1527  		and.l		#$000000ff,d1
00001B02  C4BC 000000FF                   1528  		and.l		#$000000ff,d2	; clear out the upper bytes
00001B08  5601                            1529  		add.b		#3,d1
00001B0A  5402                            1530  		add.b		#2,d2
00001B0C  41F9 00008D02                   1531  		lea		x_y,a0
00001B12  2002                            1532  		move.l		d2,d0
00001B14  2401                            1533  		move.l		d1,d2		; keep x around for later
00001B16  4EB9 00001DC6                   1534  		jsr		div10
00001B1C                                  1535  
00001B1C  B03C 0000                       1536  		cmp.b		#0,d0		; test if zero in d0
00001B20  6700 0008                       1537  		beq		g_lblaa
00001B24  0600 0030                       1538  		add.b		#'0',d0
00001B28  10C0                            1539  		move.b		d0,(a0)+
00001B2A                                  1540  
00001B2A  0601 0030                       1541  g_lblaa:	add.b		#'0',d1
00001B2E  10C1                            1542  		move.b		d1,(a0)+
00001B30                                  1543  		
00001B30  10FC 003B                       1544  		move.b		#';',(a0)+
00001B34                                  1545  
00001B34  2002                            1546  		move.l		d2,d0
00001B36  4EB9 00001DC6                   1547  		jsr		div10
00001B3C                                  1548  
00001B3C  B03C 0000                       1549  		cmp.b		#0,d0
00001B40  6700 0008                       1550  		beq		g_lblbb
00001B44  0600 0030                       1551  		add.b		#'0',d0
00001B48  10C0                            1552  		move.b		d0,(a0)+
00001B4A                                  1553  
00001B4A  0601 0030                       1554  g_lblbb:	add.b		#'0',d1
00001B4E  10C1                            1555  		move.b		d1,(a0)+
00001B50                                  1556  
00001B50  10FC 0048                       1557  		move.b		#'H',(a0)+
00001B54  10FC 0000                       1558  		move.b		#0,(a0)+		; enter in a NULL
00001B58                                  1559  
00001B58  41F9 00008D00                   1560  		lea		g_xy,a0
00001B5E  4EB9 00001D98                   1561  		jsr		prt_str
00001B64                                  1562  
00001B64  4CDF 0107                       1563  		movem.l		(sp)+,d0/d1/d2/a0
00001B68  4E75                            1564  		rts
00001B6A                                  1565  
00001B6A                                  1566  ********************************************************************************
00001B6A                                  1567  *	readxy - reads the location (x,y) from the tetris field
00001B6A                                  1568  *	Input:	d1 - x	( x and y are treated as unsigned word values)
00001B6A                                  1569  *			d2 - y
00001B6A                                  1570  *	Output: 	d0 - value from the field at (x,y), or -1 if not in field
00001B6A                                  1571  ********************************************************************************
00001B6A  48E7 6080                       1572  readxy:		movem.l		d1/d2/a0,-(sp)		; save registers
00001B6E  C2BC 000000FF                   1573  		and.l		#$000000ff,d1
00001B74  C4BC 000000FF                   1574  		and.l		#$000000ff,d2	; make sure it's only the byte value
00001B7A  B23C 0000                       1575  		cmp.b		#0,d1
00001B7E  6D00 002E                       1576  		blt		lblz
00001B82  B43C 0000                       1577  		cmp.b		#0,d2
00001B86  6D00 0026                       1578  		blt		lblz
00001B8A  B23C 0009                       1579  		cmp.b		#9,d1
00001B8E  6E00 001E                       1580  		bgt		lblz
00001B92  B43C 0013                       1581  		cmp.b		#19,d2
00001B96  6E00 0016                       1582  		bgt		lblz
00001B9A  E98A                            1583  		lsl.l		#4,d2				; offset for each line
00001B9C  D481                            1584  		add.l		d1,d2				; total offset from beginning of field
00001B9E  41F9 00008AE0                   1585  		lea		field2,a0
00001BA4  D1C2                            1586  		adda.l		d2,a0
00001BA6  1010                            1587  		move.b		(a0),d0		; get the data, the 2 is needed for
00001BA8                                  1588  								* the offset because of the space and '|'
00001BA8  4CDF 0106                       1589  lbly:		movem.l		(sp)+,d1/d2/a0		; restore registers
00001BAC  4E75                            1590  		rts
00001BAE  70FF                            1591  lblz:		move.l		#-1,d0
00001BB0  60F6                            1592  		bra		lbly
00001BB2                                  1593  *******************************************************************************
00001BB2                                  1594  *	writexy - almost as same as readxy, but writes d0 to (d1,d2)
00001BB2                                  1595  *******************************************************************************
00001BB2  48E7 E080                       1596  writexy:	movem.l		d0/d1/d2/a0,-(sp)	; save regs
00001BB6                                  1597   * write it to the screen
00001BB6  C2BC 000000FF                   1598  		and.l		#$000000ff,d1
00001BBC  C4BC 000000FF                   1599  		and.l		#$000000ff,d2
00001BC2                                  1600  
00001BC2  4EB8 1AF8                       1601  		jsr		gotoxy
00001BC6  4E43                            1602  		trap		#3
00001BC8  41F9 00008A8C                   1603  		lea		movBack,a0
00001BCE  4EB9 00001D98                   1604  		jsr		prt_str
00001BD4                                  1605  
00001BD4                                  1606  	* enter it into the 'field' so that the data is recorded
00001BD4  41F9 00008AE0                   1607  		lea		field2,a0
00001BDA  E98A                            1608  		lsl.l		#4,d2		; times 16
00001BDC  D282                            1609  		add.l		d2,d1		; add in x offset
00001BDE  D1C1                            1610  		adda.l		d1,a0
00001BE0  1080                            1611  		move.b		d0,(a0)		; enter the data into the field		 
00001BE2                                  1612  
00001BE2  4CDF 0107                       1613  		movem.l		(sp)+,d0/d1/d2/a0
00001BE6  4E75                            1614  		rts
00001BE8                                  1615  
00001BE8                                  1616  ********************************************************************************
00001BE8                                  1617  *
00001BE8                                  1618  *	END OF TETRIS SUBROUTINES
00001BE8                                  1619  *
00001BE8                                  1620  ********************************************************************************
00001BE8                                  1621  
00001BE8                                  1622  
00001BE8                                  1623  
00001BE8                                  1624  
00001BE8                                  1625  ********************************************************************************
00001BE8                                  1626  *	rd_time	- prompts and reads in the time from the user
00001BE8                                  1627  *	Input - None
00001BE8                                  1628  *	Output - the (hh:mm:ss) that the user entered
00001BE8                                  1629  *		d0 - 0 if invalid input, 1 - valid input ( which means valid/invalid output too )
00001BE8                                  1630  *		d1 - seconds
00001BE8                                  1631  *		d2 - minutes
00001BE8                                  1632  *		d3 - hours
00001BE8                                  1633  ********************************************************************************
00001BE8  48E7 0080                       1634  rd_time:	movem.l	a0,-(sp)		; save a0
00001BEC  4EB9 00001DB0                   1635  		jsr	newline
00001BF2  41F9 000081B1                   1636  		lea	ihdr2,a0
00001BF8  4EB9 00001D98                   1637  		jsr	prt_str		; print the prompt for the input
00001BFE                                  1638  
00001BFE  41F9 0000836A                   1639  		lea	input,a0
00001C04  4EB9 000025F6                   1640  		jsr	read_in			; read in the input
00001C0A                                  1641  	* process the input
00001C0A  4281                            1642  		clr.l	d1
00001C0C  4282                            1643  		clr.l	d2		; clear out the return registers just in case
00001C0E  4283                            1644  		clr.l	d3
00001C10  1018                            1645  		move.b	(a0)+,d0		; read in the first character of the hours
00001C12  4EB9 00001D0C                   1646  		jsr	testTm
00001C18  B03C 0000                       1647  		cmp.b	#0,d0
00001C1C  6700 00D8                       1648  		beq	rdTErr
00001C20  0400 0030                       1649  		sub.b	#'0',d0		; subtract offset
00001C24  1600                            1650  		move.b	d0,d3		; move into the hours part
00001C26  E70B                            1651  		lsl.b	#3,d3
00001C28  E308                            1652  		lsl.b	#1,d0
00001C2A  D600                            1653  		add.b	d0,d3		; finish multiply by ten
00001C2C                                  1654  		
00001C2C  1018                            1655  		move.b	(a0)+,d0
00001C2E  4EB9 00001D0C                   1656  		jsr	testTm		; check the second digit of hours
00001C34  B03C 0000                       1657  		cmp.b	#0,d0
00001C38  6700 00BC                       1658  		beq	rdTErr
00001C3C  0400 0030                       1659  		sub.b	#'0',d0
00001C40  D600                            1660  		add.b	d0,d3		; save the number of hours
00001C42  1018                            1661  		move.b	(a0)+,d0	; get next character
00001C44  B03C 003A                       1662  		cmp.b	#':',d0		; check if the digit is a colon
00001C48  6600 00AC                       1663  		bne	rdTerr		; if not, error
00001C4C  1018                            1664  		move.b	(a0)+,d0	; get the first digit of the minutes
00001C4E  4EB9 00001D0C                   1665  		jsr	testTm
00001C54  B03C 0000                       1666  		cmp.b	#0,d0
00001C58  6700 009C                       1667  		beq	rdTerr
00001C5C  0400 0030                       1668  		sub.b	#'0',d0		; ascii offset
00001C60  1400                            1669  		move.b	d0,d2		; save into the minutes
00001C62  E708                            1670  		lsl.b	#3,d0		; times 8
00001C64  E30A                            1671  		lsl.b	#1,d2		; times 2
00001C66  D400                            1672  		add.b	d0,d2		; equal times ten
00001C68  1018                            1673  		move.b	(a0)+,d0
00001C6A  4EB9 00001D0C                   1674  		jsr	testTm
00001C70  B03C 0000                       1675  		cmp.b	#0,d0
00001C74  6700 0080                       1676  		beq	rdTErr
00001C78  0400 0030                       1677  		sub.b	#'0',d0		; ascii offset
00001C7C  D400                            1678  		add.b	d0,d2		; get the total number of minutes entered
00001C7E                                  1679  	* seconds
00001C7E  1018                            1680  		move.b	(a0)+,d0
00001C80  B03C 003A                       1681  		cmp.b	#':',d0
00001C84  6600 0070                       1682  		bne	rdTErr
00001C88  1018                            1683  		move.b	(a0)+,d0
00001C8A  4EB9 00001D0C                   1684  		jsr	testTm
00001C90  B03C 0000                       1685  		cmp.b	#0,d0
00001C94  6700 0060                       1686  		beq	rdTerr
00001C98  0400 0030                       1687  		sub.b	#'0',d0
00001C9C  1200                            1688  		move.b	d0,d1
00001C9E  E709                            1689  		lsl.b	#3,d1		; times 8
00001CA0  E308                            1690  		lsl.b	#1,d0		; times 2
00001CA2  D200                            1691  		add.b	d0,d1		; times 10 total
00001CA4  1018                            1692  		move.b	(a0)+,d0
00001CA6  4EB9 00001D0C                   1693  		jsr	testTm
00001CAC  B03C 0000                       1694  		cmp.b	#0,d0
00001CB0  6700 0044                       1695  		beq	rdTerr
00001CB4  0400 0030                       1696  		sub.b	#'0',d0
00001CB8  D200                            1697  		add.b	d0,d1		; get the total number of seconds
00001CBA  1018                            1698  		move.b	(a0)+,d0
00001CBC                                  1699  		
00001CBC  103C 007F                       1700  		move.b	#$7f,d0		; turn valid input on
00001CC0                                  1701  
00001CC0  B63C 0017                       1702  		cmp.b	#23,d3		; check the hours
00001CC4  6E00 0030                       1703  		bgt	rdTErr
00001CC8  B63C 0000                       1704  		cmp.b	#0,d3
00001CCC  6D00 0028                       1705  		blt	rdTErr
00001CD0  B43C 003B                       1706  		cmp.b	#59,d2		; check minutes
00001CD4  6E00 0020                       1707  		bgt	rdTErr
00001CD8  B43C 0000                       1708  		cmp.b	#0,d2	
00001CDC  6D00 0018                       1709  		blt	rdTErr
00001CE0  B23C 003B                       1710  		cmp.b	#59,d1		; check seconds
00001CE4  6E00 0010                       1711  		bgt	rdTErr
00001CE8  B23C 0000                       1712  		cmp.b	#0,d1
00001CEC  6D00 0008                       1713  		blt	rdTErr	
00001CF0                                  1714  
00001CF0  4CDF 0100                       1715  rdTEnd:		movem.l	(sp)+,a0		; restore register
00001CF4  4E75                            1716  		rts				; return from subroutine
00001CF6                                  1717  
00001CF6  4280                            1718  rdTErr:		clr.l	d0
00001CF8  4EB9 00001DB0                   1719  		jsr	newline
00001CFE  41F9 000081CE                   1720  		lea	ihdr3,a0
00001D04  4EB9 00001D98                   1721  		jsr	prt_str
00001D0A  60E4                            1722  		bra	rdTEnd
00001D0C                                  1723  
00001D0C                                  1724  ******************
00001D0C                                  1725  * test the character entered to see if it was a valid character
00001D0C                                  1726  * if invalid, d0 is zero, otherwise it is the character still
00001D0C                                  1727  testTm:	
00001D0C  B03C 0030                       1728  		cmp.b	#'0',d0
00001D10  6D00 000C                       1729  		blt	TmNot
00001D14  B03C 0039                       1730  		cmp.b	#'9',d0
00001D18  6E00 0004                       1731  		bgt	TmNot
00001D1C  4E75                            1732  		rts
00001D1E  4280                            1733  TmNot:		clr.l	d0
00001D20  4E75                            1734  		rts
00001D22                                  1735  
00001D22                                  1736  ********************************************************************************
00001D22                                  1737  *  t_time - Translate the time into a string
00001D22                                  1738  *  Input: d1 - seconds
00001D22                                  1739  *         d2 - minutes
00001D22                                  1740  *         d3 - hours
00001D22                                  1741  *         d4 - leading zeros on or off ( 1-on, 0-off )
00001D22                                  1742  *	  d5 - temp variable
00001D22                                  1743  *	  a1 - address to store the string
00001D22                                  1744  ********************************************************************************
00001D22  48E7 FC40                       1745  t_time:		movem.l	d0/d1/d2/d3/d4/d5/a1,-(sp)
00001D26  4280                            1746  		clr.l	d0
00001D28  1A01                            1747           	move.b	d1,d5		; temp save of the seconds
00001D2A  1003                            1748           	move.b	d3,d0		; do the hours first
00001D2C  4EB9 00001DC6                   1749           	jsr	div10		; divide by ten, tens digit in d0, remainder in d1
00001D32  B03C 0000                       1750           	cmp.b	#0,d0		; test if it is a leading zero
00001D36  6600 0012                       1751           	bne	t_notzero
00001D3A                                  1752  	*else it is a zero
00001D3A  B83C 0000                       1753           	cmp.b	#0,d4	; test if show leading zero on/off
00001D3E  6600 000A                       1754           	bne	t_notzero	; treat it like any other number if on
00001D42                                  1755        * else we have to skip over it
00001D42  12FC 0020                       1756        		move.b	#' ',(a1)+		; enter in a space to the string
00001D46  6000 0008                       1757        		bra	t_hours
00001D4A  0600 0030                       1758  t_notzero:	add.b	#'0',d0		; get the ascii char code
00001D4E  12C0                            1759  		move.b	d0,(a1)+		; enter into string
00001D50  0601 0030                       1760  t_hours:	add.b	#'0',d1		; get the remainder's ascii value
00001D54  12C1                            1761  		move.b	d1,(a1)+			; enter into the string
00001D56  12FC 003A                       1762        		move.b	#':',(a1)+
00001D5A  4280                            1763        		clr.l	d0
00001D5C  1002                            1764        		move.b	d2,d0		; time for the minutes
00001D5E  4EB9 00001DC6                   1765        		jsr	div10		; div by ten
00001D64  0600 0030                       1766        		add.b	#'0',d0
00001D68  12C0                            1767        		move.b	d0,(a1)+		; enter into the string
00001D6A  0601 0030                       1768        		add.b	#'0',d1
00001D6E  12C1                            1769        		move.b	d1,(a1)+		; enter the second minute digit into the string
00001D70  12FC 003A                       1770   		move.b	#':',(a1)+
00001D74  4280                            1771        		clr.l	d0			; time for the seconds
00001D76  1005                            1772        		move.b	d5,d0
00001D78  4EB9 00001DC6                   1773        		jsr	div10
00001D7E  0600 0030                       1774        		add.b	#'0',d0
00001D82  12C0                            1775        		move.b	d0,(a1)+
00001D84  0601 0030                       1776        		add.b	#'0',d1
00001D88  12C1                            1777        		move.b	d1,(a1)+
00001D8A  12FC 0020                       1778        		move.b	#' ',(a1)+
00001D8E  12BC 0000                       1779        		move.b	#0,(a1)		; enter in a NULL to finish the string
00001D92                                  1780  
00001D92  4CDF 023F                       1781  		movem.l	(sp)+,d0/d1/d2/d3/d4/d5/a1
00001D96  4E75                            1782              	rts
00001D98                                  1783  
00001D98                                  1784  *---------------------------------------------------------------------------------
00001D98                                  1785  *	prt_str - prints a string in the location pointed to by a0
00001D98                                  1786  *	Input:	a0 - the address of the string
00001D98                                  1787  *	Output:	none.
00001D98                                  1788  *---------------------------------------------------------------------------------
00001D98  48E7 8080                       1789  prt_str:	movem.l	d0/a0,-(sp)
00001D9C                                  1790  
00001D9C  1018                            1791  prt_lp:		move.b	(a0)+,d0	; get the character
00001D9E  B03C 0000                       1792  		cmp.b	#0,d0		; test if NULL
00001DA2  6700 0006                       1793  		beq	prtdone		; if null, then done
00001DA6  4E43                            1794  		trap	#3		; print the character.
00001DA8  60F2                            1795  		bra	prt_lp		; loop until a null if found
00001DAA                                  1796  
00001DAA  4CDF 0101                       1797  prtdone:	movem.l	(sp)+,d0/a0
00001DAE  4E75                            1798  		rts
00001DB0                                  1799  
00001DB0                                  1800  *---------------------------------------------------------------------------------
00001DB0                                  1801  *	newline: print a newline to the screen.
00001DB0                                  1802  *---------------------------------------------------------------------------------
00001DB0  48E7 8000                       1803  newline:	movem.l	d0,-(sp)	; save d0
00001DB4  103C 000A                       1804  		move.b	#$0A,d0		; line feed
00001DB8  4E43                            1805  		trap	#3		; print
00001DBA  103C 000D                       1806  		move.b	#$0D,d0		; return
00001DBE  4E43                            1807  		trap	#3		; print
00001DC0  4CDF 0001                       1808  		movem.l	(sp)+,d0	; restore d0
00001DC4  4E75                            1809  		rts			; return
00001DC6                                  1810  *---------------------------------------------------------------------------------
00001DC6                                  1811  * Subroutine to divide 32 bit number by 10.
00001DC6                                  1812  * Input:  32bit dividend in D0
00001DC6                                  1813  * Output:  32bit quotion in D0 and remainder in D1
00001DC6                                  1814  *          (Note: remainder is only 4 bit, why?)
00001DC6                                  1815  * Algorithm:  Standard shift and subtract, repeated
00001DC6                                  1816  *---------------------------------------------------------------------------------
00001DC6  48E7 3000                       1817  div10:		movem.l	d2/d3,-(sp)
00001DCA  2400                            1818  		move.l	d0,d2
00001DCC  7000                            1819  		moveq	#0,d0		; Init. new quotion: D0.L
00001DCE  7200                            1820  		moveq	#0,d1		; Init. remainder: D1.L
00001DD0  E79A                            1821  		rol.l	#3,d2		; Preshift 'dend by 'sor size -1.
00001DD2  1202                            1822  		move.b	d2,d1		; Since 'sor is only 4 bits long, use
00001DD4  C23C 0007                       1823  		and.b	#7,d1		;    D1.B as temporary 'dend holder.
00001DD8  761C                            1824  		moveq	#28,d3		; Total 29 shift and subtract ops.
00001DDA  E38A                            1825  dvloop:		lsl.l	#1,d2		; Dividend shift one bit.
00001DDC  E311                            1826  		roxl.b	#1,d1
00001DDE  0401 000A                       1827  		sub.b	#10,d1		; Subtract divisor from dividend.
00001DE2  6500 000A                       1828  		bcs	q0		; Check 'dend<'sor.
00001DE6  003C 0010                       1829  		ori.b	#$10,ccr	; If 'dend>='sor then set quotion bit.
00001DEA  6000 000A                       1830  		bra	q_update
00001DEE  0601 000A                       1831  q0:		add.b	#10,d1		; If 'dend<'sor then restore 'dend and
00001DF2  023C 0000                       1832  		andi.b	#0,ccr		;    clear quotion bit.
00001DF6  E390                            1833  q_update:	roxl.l	#1,d0		; Include new quotion bit.
00001DF8  51CB FFE0                       1834  		dbf	d3,dvloop
00001DFC  4CDF 000C                       1835  		movem.l	(sp)+,d2/d3
00001E00  4E75                            1836  		rts
00001E02                                  1837  *---------------------------------------------------------------------------------
00001E02                                  1838  ******************************************************************************
00001E02                                  1839  *		Calculator program 
00001E02                                  1840  * 
00001E02                                  1841  hw9Calc:
00001E02  4EB8 1DB0                       1842  		jsr	newline
00001E06  41F9 000082C6                   1843  		lea	line1,a0	
00001E0C  4EB8 1D98                       1844  		jsr	prt_str		; print the heading
00001E10  4EB8 1DB0                       1845  		jsr	newline
00001E14                                  1846  
00001E14  4EB9 00001ED0                   1847  		jsr	asktype		; find out if infix or postfix notation
00001E1A                                  1848  
00001E1A  4EB8 1DB0                       1849  loop:		jsr	newline
00001E1E  41F9 00008344                   1850  		lea	prompt,a0	; address of the prompt
00001E24  4EB8 1D98                       1851  		jsr	prt_str		;  go print it
00001E28                                  1852  
00001E28  41F9 0000836A                   1853  		lea	input,a0	; set address to store the input
00001E2E  4EB9 000025F6                   1854  		jsr	read_in		; read in the input from the prompt
00001E34  43F9 00008781                   1855  		lea	exit,a1		; load exit string, 
00001E3A  41F9 0000836A                   1856  		lea	input,a0
00001E40                                  1857  		
00001E40  B109                            1858  		cmpm.b	(a1)+,(a0)+	; test 'e'
00001E42  6600 0020                       1859  		bne	noexit
00001E46  B109                            1860  		cmpm.b	(a1)+,(a0)+	; test 'x'
00001E48  6600 001A                       1861  		bne	noexit
00001E4C  B109                            1862  		cmpm.b	(a1)+,(a0)+	; test 'i'
00001E4E  6600 0014                       1863  		bne	noexit
00001E52  B109                            1864  		cmpm.b	(a1)+,(a0)+	; test 't'
00001E54  6600 000E                       1865  		bne	noexit
00001E58                                  1866  
00001E58  41F9 00008786                   1867  		lea	bye,a0
00001E5E  4EB8 1D98                       1868  		jsr	prt_str		; print 'exiting...'
00001E62                                  1869  
00001E62  4E75                            1870  		rts			; return to the main loop
00001E64                                  1871  
00001E64  43F9 00008702                   1872  noexit:		lea	uansr,a1	; check for infix/postfix representation
00001E6A  1211                            1873  		move.b	(a1),d1		
00001E6C  B23C 0000                       1874  		cmp.b	#0,d1		; if zero, then in postfix
00001E70  6700 0016                       1875  		beq	skippre		;   and the translator can be skipped
00001E74                                  1876  
00001E74  4EB9 000024B0                   1877  		jsr	in2pos		; jump to the infix to postfix translator.
00001E7A  41F9 0000842A                   1878  		lea	error,a0	; lets check if there were any errors.
00001E80  3010                            1879  		move.w	(a0),d0		; check the flags
00001E82  B03C 0000                       1880  		cmp.b	#0,d0		; if d0=0, then there were no errors
00001E86  6692                            1881  		bne	loop		; if there were errors, the messages were already printed,
00001E88                                  1882  					* the expression means nothing, so get new input
00001E88                                  1883  	* no errors, so print out the answer.
00001E88  41F9 0000834D                   1884  skippre:	lea	answer,a0
00001E8E  4EB8 1D98                       1885  		jsr	prt_str
00001E92                                  1886  		
00001E92  B23C 0000                       1887  		cmp.b	#0,d1		; check if infix/postfix notation
00001E96  6700 000C                       1888  		beq	prtPostfx
00001E9A  41F9 000083D9                   1889  		lea	expres,a0
00001EA0  6000 0008                       1890  		bra	answerPrt
00001EA4  41F9 0000836A                   1891  prtPostfx:	lea	input,a0
00001EAA  4EB8 1D98                       1892  answerPrt:	jsr	prt_str
00001EAE                                  1893  
00001EAE  103C 0020                       1894  		move.b	#' ',d0		; add in some spaces and an equal sign
00001EB2  4E43                            1895  		trap	#3
00001EB4  103C 003D                       1896  		move.b	#'=',d0
00001EB8  4E43                            1897  		trap	#3
00001EBA  103C 0020                       1898  		move.b	#' ',d0
00001EBE  4E43                            1899  		trap	#3
00001EC0                                  1900  
00001EC0  4EB9 00001F3C                   1901  		jsr	calc		; go and calculate the answer
00001EC6                                  1902  					* also prints it
00001EC6  4EB8 1DB0                       1903  		jsr	newline
00001ECA  6000 FF4E                       1904  		bra	loop		; do over again infinitely
00001ECE                                  1905  
00001ECE  4AFC                            1906  		illegal			; Main program ends here...never reached
00001ED0                                  1907  
00001ED0                                  1908  *
00001ED0                                  1909  *   PUT YOUR SUBROUTINES HERE!
00001ED0                                  1910  *
00001ED0                                  1911  *---------------------------------------------------------------------------------
00001ED0                                  1912  *	asktype - Asks the user if he/she will be using infix or postfix notation
00001ED0                                  1913  *		  in their expressions.
00001ED0                                  1914  *	Input:	None
00001ED0                                  1915  *	Output:	d0 - 0 if user pick postfix notation, 1 if infix
00001ED0                                  1916  *	Variables:
00001ED0                                  1917  *		a0 - address of the header to print
00001ED0                                  1918  *		a1 - address of the answer byte in memeory
00001ED0                                  1919  *---------------------------------------------------------------------------------
00001ED0  48E7 00C0                       1920  asktype:	movem.l	a0/a1,-(sp)	; save the registers
00001ED4  41F9 000086BF                   1921  		lea	qstion,a0
00001EDA  4EB8 1D98                       1922  		jsr	prt_str
00001EDE  43F9 00008702                   1923  		lea	uansr,a1	; address of the answer byte
00001EE4                                  1924  		
00001EE4  4E41                            1925  askloop:	trap	#1		; check if key pressed
00001EE6  B03C 0000                       1926  		cmp.b	#0,d0		
00001EEA  67F8                            1927  		beq 	askloop		; poll the keyboard until a keypress
00001EEC  4E42                            1928  		trap	#2
00001EEE  B03C 0049                       1929  		cmp.b	#'I',d0
00001EF2  6700 001C                       1930  		beq	askInfx
00001EF6  B03C 0069                       1931  		cmp.b	#'i',d0
00001EFA  6700 0014                       1932  		beq	askInfx
00001EFE  B03C 0050                       1933  		cmp.b	#'P',d0
00001F02  6700 001A                       1934  		beq	askPstfx
00001F06  B03C 0070                       1935  		cmp.b	#'p',d0
00001F0A  6700 0012                       1936  		beq	askPstfx
00001F0E                                  1937  
00001F0E  60D4                            1938  		bra	askloop
00001F10                                  1939  
00001F10  103C 0001                       1940  askInfx:	move.b	#1,d0
00001F14  41F9 00008703                   1941  		lea	answrI,a0
00001F1A  6000 000A                       1942  		bra	askend
00001F1E  4200                            1943  askPstfx:	clr.b	d0
00001F20  41F9 00008726                   1944  		lea	answrP,a0
00001F26  4EB8 1DB0                       1945  askend:		jsr	newline
00001F2A  4EB8 1D98                       1946  		jsr	prt_str
00001F2E  1280                            1947  		move.b	d0,(a1)			; store the answer
00001F30  4CDF 0300                       1948  		movem.l	(sp)+,a0/a1		; restore the registers
00001F34  4E75                            1949  		rts
00001F36                                  1950  *---------------------------------------------------------------------------------
00001F36                                  1951  *	ckexit - test if the user typed in 'exit'
00001F36                                  1952  *	Input:	a0 - the address of the user's input
00001F36                                  1953  *	Output: None.  If the user entered 'exit' then goto Illegal, otherise, returns
00001F36                                  1954  *	Variables: a0 - address of input string
00001F36                                  1955  *		   a1 - address of 'exit' string
00001F36                                  1956  *---------------------------------------------------------------------------------
00001F36  48E7 00C0                       1957  ckexit:		movem.l	a0/a1,-(sp)	; save address registers
00001F3A  4E75                            1958  		rts
00001F3C                                  1959  *---------------------------------------------------------------------------------
00001F3C                                  1960  *	calc - calculates the answer to the expression
00001F3C                                  1961  *	Input:	The postfix notated expression to be transalated.
00001F3C                                  1962  *	Output:	Prints to the screen the decimal answer, also stored at 'result'
00001F3C                                  1963  *	Variables:
00001F3C                                  1964  *		a0 - address of the postfix notation
00001F3C                                  1965  *		a1 - temporary stack pointer for the operands
00001F3C                                  1966  *		a2 - address of the error flags
00001F3C                                  1967  *		d0 - used to print the answer to terminal
00001F3C                                  1968  *		d1 - first number off the stack
00001F3C                                  1969  *		d2 - second number off the stack, also the answer in two operand ops
00001F3C                                  1970  *		d3 - the error flags of this calculation
00001F3C                                  1971  *		d4 - used temporarily in mult and div to keep track of sign
00001F3C                                  1972  *	Note:  	The multiply and divide sections were made to calculate the answer
00001F3C                                  1973  *		with unsigned numbers, and do error checking before adjusting for
00001F3C                                  1974  *		the true sign of the answer.  This may make is seem (more) confusing
00001F3C                                  1975  *		than it should be.
00001F3C                                  1976  *
00001F3C                                  1977  *---------------------------------------------------------------------------------
00001F3C  48E7 F8E0                       1978  calc:		movem.l	d0/d1/d2/d3/d4/a0/a1/a2,-(sp)		; save registers
00001F40  43F9 0000877C                   1979  		lea	cstack,a1	; load the stack address
00001F46  45F9 00008859                   1980  		lea	cerrflg,a2	; load the error flag address
00001F4C  4283                            1981  		clr.l	d3		; clear error flags
00001F4E                                  1982  	* determine the address of the input string
00001F4E  41F9 00008702                   1983  		lea	uansr,a0	; get answer to infix/postfix question
00001F54  1010                            1984  		move.b	(a0),d0
00001F56  B03C 0000                       1985  		cmp.b	#0,d0		; if d0==0, then user entered postfix notation
00001F5A  6600 000C                       1986  		bne	c_infix
00001F5E  41F9 0000836A                   1987  		lea	input,a0
00001F64  6000 0008                       1988  		bra	c_loop
00001F68  41F9 000083D9                   1989  c_infix:	lea	expres,a0
00001F6E                                  1990  c_loop:	* check if there was an error on the previous process.
00001F6E  B63C 0000                       1991  		cmp.b	#0,d3		; test if there were any errors
00001F72  6700 000A                       1992  		beq	c_no_errs
00001F76                                  1993  		
00001F76  0803 0004                       1994  		btst	#4,d3		; test for divide by zero
00001F7A  6600 0158                       1995  		bne	c_errors	; if set, then exit, can not continue.
00001F7E                                  1996  					* otherwise, it's an overflow error, so keep on going...
00001F7E                                  1997  
00001F7E  1018                            1998  c_no_errs:	move.b	(a0)+,d0	; get the first character from the stack
00001F80  B03C 0020                       1999  		cmp.b	#' ',d0		; check if a space
00001F84  67E8                            2000  		beq	c_loop
00001F86  B03C 005E                       2001  		cmp.b	#'^',d0		; unary negation
00001F8A  6700 0074                       2002  		beq	c_nega
00001F8E  B03C 002A                       2003  		cmp.b	#'*',d0		; check if multiply
00001F92  6700 0076                       2004  		beq	c_mult
00001F96  B03C 002F                       2005  		cmp.b	#'/',d0		; division
00001F9A  6700 00CA                       2006  		beq	c_div
00001F9E  B03C 002B                       2007  		cmp.b	#'+',d0		; add
00001FA2  6700 0104                       2008  		beq	c_add
00001FA6  B03C 002D                       2009  		cmp.b	#'-',d0		; subtract
00001FAA  6700 0112                       2010  		beq	c_sub
00001FAE                                  2011  
00001FAE  B03C 0030                       2012  		cmp.b	#'0',d0
00001FB2  6D00 0040                       2013  		blt	c_strng
00001FB6  B03C 0039                       2014  		cmp.b	#'9',d0
00001FBA  6E00 0038                       2015  		bgt	c_strng
00001FBE                                  2016  *---------------------------------------------------------------------------------
00001FBE                                  2017  	* it's a digit, so read it in and place on temp stack
00001FBE  4281                            2018  		clr.l	d1
00001FC0  0400 0030                       2019  c_digit:	sub.b	#$30,d0		; sub ASCII offset
00001FC4  2401                            2020  		move.l	d1,d2
00001FC6  E781                            2021  		asl.l	#3,d1		;   	  d1 * 8
00001FC8  E382                            2022  		asl.l	#1,d2		; 	+ d1 * 2
00001FCA  D282                            2023  		add.l	d2,d1		; total=  d1 * 10
00001FCC  6500 001E                       2024  		bcs	toobig
00001FD0  D280                            2025  c_slip:		add.l	d0,d1
00001FD2  6900 0018                       2026  		bvs	toobig
00001FD6  1018                            2027  		move.b	(a0)+,d0
00001FD8  B03C 0020                       2028  		cmp.b	#' ',d0		; test if a space
00001FDC  66E2                            2029  		bne	c_digit		; continue until a space in entered
00001FDE  B2BC 00000000                   2030  		cmp.l	#0,d1		; test if the answer is still +
00001FE4  6D00 0006                       2031  		blt	toobig
00001FE8  2301                            2032  		move.l	d1,-(a1)
00001FEA  6082                            2033  		bra	c_loop
00001FEC                                  2034  
00001FEC  863C 0008                       2035  toobig:		or.b	#8,d3		; set error flag
00001FF0  6000 00E2                       2036  		bra	c_errors
00001FF4                                  2037  
00001FF4                                  2038  *---------------------------------------------------------------------------------
00001FF4                                  2039  * it was a strange character... for now just skip over it
00001FF4  B03C 0000                       2040  c_strng:	cmp.b	#0,d0		; test if NULL was found
00001FF8  6700 00DA                       2041  		beq	c_errors	; if so, check for overflows and leave
00001FFC  6000 FF70                       2042  		bra	c_loop		; otherwise, skip it
00002000                                  2043  
00002000                                  2044  *---------------------------------------------------------------------------------
00002000                                  2045  *  unary negation operation
00002000  2219                            2046  c_nega:		move.l	(a1)+,d1	; read off the top of the stack
00002002  4481                            2047  		neg.l	d1		; negate the operand
00002004  2301                            2048  		move.l	d1,-(a1)	; push the answer back on to the stack
00002006  6000 FF66                       2049  		bra	c_loop		; continue
0000200A                                  2050  
0000200A                                  2051  *---------------------------------------------------------------------------------
0000200A                                  2052  *  multiply
0000200A  2419                            2053  c_mult:		move.l	(a1)+,d2	; read off the second operand
0000200C  2219                            2054  		move.l	(a1)+,d1	; read off the first operand
0000200E                                  2055  
0000200E  4284                            2056  		clr.l	d4		; clear the temp register
00002010  B2BC 00000000                   2057  		cmp.l	#0,d1		; test if d1 is negative
00002016  6C00 0006                       2058  		bge	cm_pos
0000201A  4481                            2059  		neg.l	d1
0000201C  7801                            2060  		move.l	#1,d4
0000201E  B4BC 00000000                   2061  cm_pos:		cmp.l	#0,d2		; test if d2 is negative
00002024  6C00 0006                       2062  		bge	cm_2pos
00002028  4482                            2063  		neg.l	d2
0000202A  5284                            2064  		add.l	#1,d4
0000202C                                  2065  	* both numbers are positive going into the multiply routine
0000202C  4EB9 000026BC                   2066  cm_2pos:	jsr	mult32		; jump to subroutine to multiply
00002032  B4BC 00000000                   2067  		cmp.l	#0,d2		; test out the MSBs of the answer
00002038  6700 000A                       2068  		beq	c_mtst
0000203C  863C 0004                       2069  		or.b	#4,d3		; set error code
00002040  6000 0092                       2070  		bra	c_errors	; print the error
00002044  B2BC 00000000                   2071  c_mtst:		cmp.l	#0,d1		; test the LSB of d1
0000204A  6C00 000A                       2072  		bge	c_mneg
0000204E  863C 0004                       2073  		or.b	#4,d3
00002052  6000 0080                       2074  		bra	c_errors
00002056                                  2075  
00002056  0804 0000                       2076  c_mneg:		btst	#0,d4
0000205A  6700 0004                       2077  		beq	cm_not
0000205E  4481                            2078  		neg.l	d1		; negate to the correct answer
00002060                                  2079  
00002060  2301                            2080  cm_not:		move.l	d1,-(a1)	; push the answer back on stack
00002062  6000 FF0A                       2081  		bra	c_loop
00002066                                  2082  *---------------------------------------------------------------------------------
00002066                                  2083  * divide
00002066  2419                            2084  c_div:		move.l	(a1)+,d2
00002068  2219                            2085  		move.l	(a1)+,d1
0000206A                                  2086  
0000206A  7800                            2087  		move.l	#0,d4		; clear temp register
0000206C  B4BC 00000000                   2088  		cmp.l	#0,d2		; test if d2 is zero
00002072  6C00 0006                       2089  		bge	d_tst_nxt
00002076  4482                            2090  		neg.l	d2		; negate if neccessary
00002078  7801                            2091  		move.l	#1,d4		; set the temp to 1
0000207A                                  2092  
0000207A  B2BC 00000000                   2093  d_tst_nxt:	cmp.l	#0,d1		; test if d1 is <0
00002080  6C00 0006                       2094  		bge	dTstDone
00002084  4481                            2095  		neg.l	d1		; negate d1
00002086  5284                            2096  		add.l	#1,d4		; will either set or clear if a change of sign is needed
00002088                                  2097  
00002088  4EB9 0000266E                   2098  dTstDone:	jsr	div32		; divide two unsigned 32 bit numbers
0000208E  8602                            2099  		or.b	d2,d3		; set the error flag if needed.
00002090  B43C 0000                       2100  		cmp.b	#0,d2		; test error code
00002094  6600 000C                       2101  		bne	c_div_done	; if not zero, then there was a zero divide
00002098                                  2102  
00002098  0804 0000                       2103  		btst	#0,d4		; test if both operands were the same sign
0000209C  6700 0004                       2104  		beq	c_div_done	; if d4[0]==0, then both operands the same sign
000020A0  4481                            2105  		neg.l	d1		; negate the answer
000020A2                                  2106  
000020A2  2301                            2107  c_div_done:	move.l	d1,-(a1)	; push the answer onto the stack
000020A4  6000 FEC8                       2108  		bra	c_loop
000020A8                                  2109  *---------------------------------------------------------------------------------
000020A8                                  2110  * add
000020A8  2419                            2111  c_add:		move.l	(a1)+,d2	
000020AA  2219                            2112  		move.l	(a1)+,d1
000020AC  D481                            2113  		add.l	d1,d2
000020AE  6900 0008                       2114  		bvs	e_add
000020B2  2302                            2115  c_aslip:	move.l	d2,-(a1)
000020B4  6000 FEB8                       2116  		bra	c_loop
000020B8  863C 0001                       2117  e_add:		or.b	#1,d3
000020BC  60F4                            2118  		bra	c_aslip
000020BE                                  2119  *---------------------------------------------------------------------------------
000020BE                                  2120  * subtract
000020BE  2419                            2121  c_sub:		move.l	(a1)+,d2
000020C0  2219                            2122  		move.l	(a1)+,d1
000020C2  9282                            2123  		sub.l	d2,d1
000020C4  6900 0008                       2124  		bvs	e_sub
000020C8  2301                            2125  c_sslip:	move.l	d1,-(a1)
000020CA  6000 FEA2                       2126  		bra	c_loop
000020CE  863C 0002                       2127  e_sub:		or.b	#2,d3
000020D2  60F4                            2128  		bra	c_sslip
000020D4                                  2129  *---------------------------------------------------------------------------------
000020D4  B63C 0000                       2130  c_errors:	cmp.b	#0,d3		; test for errors
000020D8  6700 0064                       2131  		beq	c_exit		; there were no errors, exit
000020DC                                  2132  	* at least one error
000020DC  4EB8 1DB0                       2133  		jsr	newline
000020E0  0803 0000                       2134  		btst	#0,d3		; test if it was error A
000020E4  6700 000C                       2135  		beq	ctsterrB
000020E8  41F9 0000879C                   2136  		lea	cerrorA,a0
000020EE  4EB8 1D98                       2137  		jsr	prt_str
000020F2  0803 0001                       2138  ctsterrB:	btst	#1,d3
000020F6  6700 000C                       2139  		beq	ctsterrC
000020FA  41F9 000087C0                   2140  		lea	cerrorB,a0
00002100  4EB8 1D98                       2141  		jsr	prt_str
00002104  0803 0002                       2142  ctsterrC:	btst	#2,d3
00002108  6700 000C                       2143  		beq	ctsterrD
0000210C  41F9 000087E7                   2144  		lea	cerrorC,a0
00002112  4EB8 1D98                       2145  		jsr	prt_str
00002116  0803 0003                       2146  ctsterrD:	btst	#3,d3
0000211A  6700 000C                       2147  		beq	ctsterrE
0000211E  41F9 00008811                   2148  		lea	cerrorD,a0
00002124  4EB8 1D98                       2149  		jsr	prt_str
00002128                                  2150  
00002128  0803 0004                       2151  ctsterrE:	btst	#4,d3
0000212C  6700 0058                       2152  		beq	c_skdone
00002130  41F9 0000883F                   2153  		lea	cerrorE,a0
00002136  4EB8 1D98                       2154  		jsr	prt_str
0000213A  6000 004A                       2155  		bra	c_skdone
0000213E                                  2156  
0000213E  1483                            2157  c_exit:		move.b	d3,(a2)		; save error flags
00002140                                  2158  	* print out the answer, which is on the stack.
00002140                                  2159  	
00002140  2419                            2160  		move.l	(a1)+,d2	; get the answer
00002142                                  2161  
00002142  B4BC 00000000                   2162  		cmp.l	#0,d2
00002148  6600 000C                       2163  		bne	cc_skip
0000214C  103C 0030                       2164  		move.b	#'0',d0
00002150  4E43                            2165  		trap	#3
00002152  6000 0032                       2166  		bra	c_skdone
00002156                                  2167  
00002156  B4BC 00000000                   2168  cc_skip:	cmp.l	#0,d2		; test if 
0000215C  6C00 000A                       2169  		bge	c_pos		;  it needs a '-' sign
00002160  103C 002D                       2170  		move.b	#'-',d0
00002164  4E43                            2171  		trap	#3		; print the '-' sign
00002166  4482                            2172  		neg.l	d2		; negate it so it's positive now
00002168  2002                            2173  c_pos:		move.l	d2,d0		; get ready...
0000216A  B0BC 00000000                   2174  c_dlp:		cmp.l	#0,d0
00002170  6700 000E                       2175  		beq	c_done
00002174  4EB8 1DC6                       2176  		jsr	div10		; to divide by ten
00002178  0601 0030                       2177  		add.b	#$30,d1		; get the		
0000217C  1301                            2178  		move.b	d1,-(a1)
0000217E  60EA                            2179  		bra	c_dlp
00002180                                  2180  
00002180  2049                            2181  c_done:		movea.l	a1,a0
00002182  4EB8 1D98                       2182  		jsr	prt_str
00002186  4CDF 071F                       2183  c_skdone:	movem.l	(sp)+,d0/d1/d2/d3/d4/a0/a1/a2		; restore the registers
0000218A  4E75                            2184  		rts
0000218C                                  2185  
0000218C                                  2186  *---------------------------------------------------------------------------------
0000218C                                  2187  *	checkpre - ask the user if he/she wants to see the output of
0000218C                                  2188  *	the preprocessor.
0000218C                                  2189  *	Input:	user enters Y or N on the keyboard.
0000218C                                  2190  *	Output: Stores a boolean value (0/1) in 'see_pre' so that we can test it
0000218C                                  2191  *		each loop to determine if we show the preprocessor output.
0000218C                                  2192  *	Variables:
0000218C                                  2193  *		d0 - used to read in from the keyboard (trap #3)
0000218C                                  2194  *		a0 - used to print the heading, and also to store the address
0000218C                                  2195  *		     of the boolean value after a Y or N has been read in.
0000218C                                  2196  *---------------------------------------------------------------------------------
0000218C  48E7 8080                       2197  checkpre:	movem.l	d0/a0,-(sp)	; save the registers.
00002190  41F9 0000865B                   2198  		lea	head3,a0
00002196  4EB8 1D98                       2199  		jsr	prt_str		; print the heading
0000219A  41F9 000086BE                   2200  		lea	see_pre,a0	; set variable address
000021A0                                  2201  
000021A0  4E41                            2202  chcklp:		trap	#1		; check the keyboard
000021A2  B03C 0000                       2203  		cmp.b	#0,d0		; test if no input
000021A6  67F8                            2204  		beq	chcklp		;  if none, then wait
000021A8  4E42                            2205  		trap	#2		; actually get the character
000021AA  B03C 006E                       2206  		cmp.b	#'n',d0		; test if a no was pressed
000021AE  6700 001C                       2207  		beq	sayNo
000021B2  B03C 004E                       2208  		cmp.b	#'N',d0		; another test for no
000021B6  6700 0014                       2209  		beq	sayNo
000021BA  B03C 0059                       2210  		cmp.b	#'Y',d0		; test if yes
000021BE  6700 0014                       2211  		beq	sayYes
000021C2  B03C 0079                       2212  		cmp.b	#'y',d0
000021C6  6700 000C                       2213  		beq	sayYes
000021CA  60D4                            2214  		bra 	chcklp		; otherwise, keep looping
000021CC  10BC 0000                       2215  sayNo:		move.b	#0,(a0)		; store zero, don't see it.
000021D0  6000 0006                       2216  		bra	chckend
000021D4  10BC 0001                       2217  sayYes:		move.b	#1,(a0)		; store a one, show it.
000021D8  4CDF 0101                       2218  chckend:	movem.l	(sp)+,d0/a0	; restore registers.
000021DC  4E75                            2219  		rts			; return
000021DE                                  2220  *---------------------------------------------------------------------------------
000021DE                                  2221  *	charread:	Reads in a character from the input string and sets it's type
000021DE                                  2222  *			for returning to the preprocessor
000021DE                                  2223  *	Input:	a0 - the address of the string, it is automatically incremented.
000021DE                                  2224  *	Output: a0 - the incremented address.
000021DE                                  2225  *		d0 - the character read in.
000021DE                                  2226  *		d1 - the type of the character read in.
000021DE                                  2227  *			1 - Digit for an operand (0-9)
000021DE                                  2228  *			2 - Operator (+,-,*,/)
000021DE                                  2229  *			3 - '('
000021DE                                  2230  *			4 - ')'
000021DE                                  2231  *			5 - Other, could be a '=' or <RETURN> or something else
000021DE                                  2232  *	Variables: Used just as indicated in Output.
000021DE                                  2233  *---------------------------------------------------------------------------------
000021DE  1018                            2234  charread:	move.b	(a0)+,d0	; get the character
000021E0  B03C 0029                       2235  		cmp.b	#')',d0 	; test if ')'
000021E4  6700 004A                       2236  		beq	rightpar
000021E8  B03C 0028                       2237  		cmp.b	#'(',d0		; test if '('
000021EC  6700 003A                       2238  		beq	leftpar	
000021F0  B03C 002B                       2239  		cmp.b	#'+',d0		; test if an operand...
000021F4  6700 0042                       2240  		beq	op_sign
000021F8  B03C 002D                       2241  		cmp.b	#'-',d0		
000021FC  6700 003A                       2242  		beq	op_sign
00002200  B03C 002A                       2243  		cmp.b	#'*',d0
00002204  6700 0032                       2244  		beq	op_sign
00002208  B03C 002F                       2245  		cmp.b	#'/',d0
0000220C  6700 002A                       2246  		beq	op_sign
00002210  B03C 0030                       2247  		cmp.b	#'0',d0		; check if it could be a digit
00002214  6D00 002A                       2248  		blt	strange
00002218  B03C 0039                       2249  		cmp.b	#'9',d0		; check upper bound
0000221C  6E00 0022                       2250  		bgt	strange
00002220                                  2251  	* else it's a digit for an operand.
00002220  123C 0001                       2252  		move.b	#1,d1		; set the value
00002224  6000 001E                       2253  		bra	crd_done
00002228  123C 0003                       2254  leftpar:	move.b	#3,d1		; left paren. value
0000222C  6000 0016                       2255  		bra	crd_done
00002230  123C 0004                       2256  rightpar:	move.b	#4,d1		; right paren
00002234  6000 000E                       2257  		bra	crd_done
00002238  123C 0002                       2258  op_sign:	move.b	#2,d1		; op sign
0000223C  6000 0006                       2259  		bra	crd_done
00002240  1238 0005                       2260  strange:	move.b	5,d1		; strange char.
00002244  4E75                            2261  crd_done:	rts			; return 
00002246                                  2262  
00002246                                  2263  *---------------------------------------------------------------------------------
00002246                                  2264  *	prepros	- the preprocessor for the in2pos subroutine.
00002246                                  2265  *	Input:	The string to be translated, at location input. (ending with a NULL)
00002246                                  2266  *	Output: The translated string at location output. (ending with a NULL)
00002246                                  2267  *	Varaiables:
00002246                                  2268  *		a0 - address of the input string, at 'input'
00002246                                  2269  *		a1 - address of the output string, at 'output'
00002246                                  2270  *		a2 - address of 'error' word
00002246                                  2271  *		d0 - the current character read in.
00002246                                  2272  *		d1 - a value corresponding to a character read in.
00002246                                  2273  *			0 - No character read in. 
00002246                                  2274  *			1 - Digit for an operand.
00002246                                  2275  *			2 - Operator
00002246                                  2276  *			3 - '('
00002246                                  2277  *			4 - ')'
00002246                                  2278  *			5 - Other ( maybe a '=' or a <RETURN> )
00002246                                  2279  *		d2 - error flags, moved into the byte location 'error'
00002246                                  2280  *			0 - no errors.
00002246                                  2281  *			1 - Operand too large (counted by digits, not foolproof)
00002246                                  2282  *			2 - Multiple operators.  (2+*4)
00002246                                  2283  *			4 - Missing right paren.
00002246                                  2284  *			8 - Missing left paren.
00002246                                  2285  *			16 - Operator without operand ( 2+ )
00002246                                  2286  *			32 - Unrecognized character
00002246                                  2287  *			64 - Empty parenthesis '()' 
00002246                                  2288  *		d3 - a value corresponding to the previous character read in (see d1)
00002246                                  2289  *		d4 - count of the number of '(', used in error checking
00002246                                  2290  *		d5 - counter for number of digits of an operand.
00002246                                  2291  *---------------------------------------------------------------------------------
00002246  48E7 FCE0                       2292  preproc:	movem.l	d0/d1/d2/d3/d4/d5/a0/a1/a2,-(sp)	; save the registers.
0000224A  41F9 0000836A                   2293  		lea	input,a0	; set input address
00002250  43F9 0000839D                   2294  		lea	output,a1	; set output address
00002256  45F9 0000842A                   2295  		lea	error,a2
0000225C  7600                            2296  		move.l	#0,d3		; no character previously read in
0000225E  7400                            2297  		move.l	#0,d2		; clear the error flags.
00002260  7800                            2298  		move.l	#0,d4		; clear number of '('
00002262                                  2299  
00002262  4EB8 21DE                       2300  		jsr	charread	; get the first character
00002266  B03C 002D                       2301  		cmp.b	#'-',d0		; test if a unary negation
0000226A  6600 0010                       2302  		bne	precheck	; if not, continue normally
0000226E  123C 0002                       2303  		move.b	#2,d1		; set previous character
00002272  12FC 005E                       2304  		move.b	#'^',(a1)+	; 	store character
00002276                                  2305  	* now continue on to the next character like normal
00002276  1601                            2306  preloop:	move.b	d1,d3		; set previous character
00002278  4EB8 21DE                       2307  preread:	jsr	charread	; get the next character
0000227C                                  2308  
0000227C  B03C 0020                       2309  precheck:	cmp.b	#$20,d0		; check if it was a space
00002280  67F6                            2310  		beq	preread		; if so, ignore
00002282  B03C 0000                       2311  		cmp.b	#0,d0		; check if NULL
00002286  6700 0158                       2312  		beq	predone
0000228A  B23C 0001                       2313  		cmp.b	#1,d1		; check if a digit
0000228E  6700 003A                       2314  		beq	predigit	
00002292  B23C 0002                       2315  		cmp.b	#2,d1		; check if an operator
00002296  6700 007C                       2316  		beq	pre_op
0000229A  B23C 0003                       2317  		cmp.b	#3,d1		; check if a '('
0000229E  6700 00CC                       2318  		beq	preleft
000022A2  B23C 0004                       2319  		cmp.b	#4,d1		; check if a ')'
000022A6  6700 00EC                       2320  		beq	prerite
000022AA                                  2321  	* otherwise it's a strange character, check if a <RETURN> or '=' or...
000022AA  B03C 0000                       2322  		cmp.b	#0,d0		; test if a NULL was found...
000022AE  6700 0130                       2323  		beq	predone		;  if so, then we are done
000022B2  B03C 000D                       2324  		cmp.b	#13,d0		; check if a <RETURN>
000022B6  6700 0128                       2325  		beq	predone		;  if so, we are done
000022BA  B03C 003D                       2326  		cmp.b	#'=',d0		; check if a '='
000022BE  6700 0120                       2327  		beq	predone		;  if so, then we are done
000022C2                                  2328  	* strange character, one that should set an error flag...	
000022C2  847C 0020                       2329  		or.w	#32,d2		; set error flags
000022C6  12C0                            2330  		move.b	d0,(a1)+	; enter in character anyway
000022C8  60AC                            2331  		bra	preloop		; go get next character and continue
000022CA                                  2332  
000022CA  1A3C 0000                       2333  predigit:	move.b	#0,d5		; set counter or MAX number of digits
000022CE  163C 0001                       2334  		move.b	#1,d3		; set the previous type
000022D2  B63C 0004                       2335  		cmp.b	#4,d3		; check previous
000022D6  6600 0006                       2336  		bne	dignxt		;   if not ')', then skip
000022DA  12FC 002A                       2337  		move.b	#'*',(a1)+	; add in a '*'
000022DE                                  2338  
000022DE  12C0                            2339  dignxt:		move.b	d0,(a1)+	; enter in character
000022E0                                  2340  	* There is no error checking because anything can come before a digit
000022E0  4EB8 21DE                       2341  		jsr	charread	; get the next character
000022E4                                  2342  		
000022E4  B03C 0030                       2343  		cmp.b	#$30,d0		; test if not a digit
000022E8  6D00 0018                       2344  		blt	digend
000022EC  B03C 0039                       2345  		cmp.b	#$39,d0		
000022F0  6E00 0010                       2346  		bgt	digend
000022F4                                  2347  
000022F4  5205                            2348  		add.b	#1,d5		; increment digit counter
000022F6  BA3C 000A                       2349  		cmp.b	#10,d5		; check number of digits...
000022FA  6DE2                            2350  		blt	dignxt		; if not over max, continue
000022FC  847C 0001                       2351  		or.w	#1,d2		; set error condition
00002300  60DC                            2352  		bra	dignxt		; loop again until non-char
00002302                                  2353  
00002302  123C 0001                       2354  digend:		move.b	#1,d1		; set current digit
00002306  3A3C 0000                       2355  		move.w	#0,d5		; reset the digit counter for next time
0000230A  91FC 00000001                   2356  		suba.l	#1,a0		; decrement the string pointere
00002310  6000 FF64                       2357  		bra	preloop
00002314                                  2358  
00002314  12C0                            2359  pre_op:		move.b	d0,(a1)+	; always move the sign to output.
00002316  B63C 0005                       2360  		cmp.b	#5,d3		; check previous=strange
0000231A  6700 FF5A                       2361  		beq	preloop		; if so, skip error checking
0000231E  B63C 0004                       2362  		cmp.b	#4,d3		; check if previous was ')'
00002322  6700 FF52                       2363  		beq	preloop		; if so, skip errors
00002326  B63C 0001                       2364  		cmp.b	#1,d3		; check if previous was digit
0000232A  6700 FF4A                       2365  		beq	preloop		; if so, go to next character
0000232E                                  2366  
0000232E  B63C 0002                       2367  		cmp.b	#2,d3		; check if previous was operator
00002332  6600 000A                       2368  		bne	p_opnxt		
00002336  847C 0002                       2369  		or.w	#2,d2		; set multiple operators error
0000233A  6000 FF3A                       2370  		bra	preloop		; next character please
0000233E                                  2371  
0000233E  B63C 0003                       2372  p_opnxt:	cmp.b	#3,d3		; test if previous was '('
00002342  6600 0012                       2373  		bne	p_oplst
00002346  B03C 002D                       2374  		cmp.b	#'-',d0		; test if current is a unary negation
0000234A  6700 0012                       2375  		beq	prenega		;  if so, nothing wrong
0000234E  847C 0010                       2376  		or.w	#16,d2		; set error of operator without operand
00002352  6000 FF22                       2377  		bra	preloop		; continue on to next character
00002356                                  2378  	* if it reaches here, then the previous was <NONE> as in it is the first character		
00002356  847C 0010                       2379  p_oplst:	or.w	#16,d2		; set error
0000235A  6000 FF1A                       2380  		bra	preloop
0000235E                                  2381  
0000235E  133C 005E                       2382  prenega:	move.b	#'^',-(a1)	; change the minus sign to the unary negation
00002362  D3FC 00000001                   2383  		adda.l	#1,a1		; increment the pointer back to were it should be
00002368  6000 FF0C                       2384  		bra	preloop
0000236C                                  2385  
0000236C  5204                            2386  preleft:	add.b	#1,d4		; increment number of '('
0000236E  B63C 0000                       2387  		cmp.b	#0,d3		; test if previous was <NONE>
00002372  6700 001A                       2388  		beq	lftmove
00002376  B63C 0002                       2389  		cmp.b	#2,d3		; test if previous was operator
0000237A  6700 0012                       2390  		beq	lftmove
0000237E  B63C 0003                       2391  		cmp.b	#3,d3		; test if previous was another '('
00002382  6700 000A                       2392  		beq	lftmove
00002386  B63C 0005                       2393  		cmp.b	#5,d3		; check if previous was some other character
0000238A                                  2394  	* this means it was either a digit or a ')', so a '*' is need to be added to string
0000238A  12FC 002A                       2395  		move.b	#'*',(a1)+	; add in a '*'
0000238E  12C0                            2396  lftmove:	move.b	d0,(a1)+	; move the character to the output
00002390                                  2397  	* no error checking here
00002390  6000 FEE4                       2398  		bra 	preloop		; go to the next character
00002394                                  2399  
00002394  5304                            2400  prerite:	sub.b	#1,d4		; decrement number of '('
00002396  12C0                            2401  		move.b	d0,(a1)+	; always move to output
00002398  B83C 0000                       2402  		cmp.b	#0,d4		; test if there are more ')' than '('
0000239C  6C00 000A                       2403  		bge	p_rtnxt		;   if there are still more '(', then skip error
000023A0  847C 0008                       2404  		or.w	#8,d2		; set error flag
000023A4  183C 0000                       2405  		move.b	#0,d4		; set to zero so that we can still get missing ')' errors later if needed.
000023A8                                  2406  
000023A8  B63C 0001                       2407  p_rtnxt:	cmp.b	#1,d3		; check if previous was digit
000023AC  6700 FEC8                       2408  		beq	preloop		;   if so, go to next
000023B0  B63C 0004                       2409  		cmp.b	#4,d3		; check if previous was another ')'
000023B4  6700 FEC0                       2410  		beq	preloop		;   if so go to next
000023B8  B63C 0005                       2411  		cmp.b	#5,d3		; check if previous was strange
000023BC  6700 FEB8                       2412  		beq	preloop		;   if so, go to next
000023C0  B63C 0000                       2413  		cmp.b	#0,d3		; check if this is the first character...
000023C4  6700 FEB0                       2414  		beq	preloop		; ...error was set because d4 was less than 0.
000023C8                                  2415  	* otherwise, there was some type of error due to the previous character, set flags...
000023C8  B63C 0002                       2416  		cmp.b	#2,d3		; check if previous was an operator..
000023CC  6600 000A                       2417  		bne	p_rtlst
000023D0  847C 0010                       2418  		or.w	#16,d2		; set the flags
000023D4  6000 FEA0                       2419  		bra	preloop		; go on to the next character
000023D8  847C 0040                       2420  p_rtlst:	or.w	#64,d2		; empty '()'
000023DC  6000 FE98                       2421  		bra	preloop	
000023E0                                  2422  
000023E0                                  2423  predone:  * check for errors....first is the number of '('....		
000023E0  B83C 0000                       2424  		cmp.b	#0,d4		; test number of '('
000023E4  6F00 0006                       2425  		ble	preleave	; zero is the correct amount
000023E8  847C 0004                       2426  		or.w	#4,d2		; set to many '(' error code
000023EC                                  2427  					*  ... too many ')' is set in 'prerite:'
000023EC  B63C 0002                       2428  preleave:	cmp.b	#2,d3		; test if last was operator
000023F0  6600 0006                       2429  		bne	preexit
000023F4  843C 0010                       2430  		or.b	#16,d2		; set error for operator without operand
000023F8                                  2431  
000023F8  3482                            2432  preexit:	move.w	d2,(a2)		; save the errors
000023FA  12BC 0000                       2433  		move.b	#0,(a1)		; enter a NULL into the string
000023FE  4CDF 073F                       2434  		movem.l (sp)+,d0/d1/d2/d3/d4/d5/a0/a1/a2	 ; restore the registers
00002402  4E75                            2435  		rts
00002404                                  2436  *---------------------------------------------------------------------------------
00002404                                  2437  *	errorprt - prints any errors according to the error flags in 'error'
00002404                                  2438  *	Input:	The input bit flags located in 'error'.
00002404                                  2439  *	Output: d0 - zero if no errors, otherwise, means there was error(s).
00002404                                  2440  *
00002404                                  2441  *	Error Flag Bits
00002404                                  2442  *	Bit#	Error Message
00002404                                  2443  *	0 	Operand contains more than 10 characters.
00002404                                  2444  *	1	Multiple operators (343*-223)
00002404                                  2445  *	2	Missing ')'.
00002404                                  2446  *	3	Missing '('.
00002404                                  2447  *	4	Operator without operand ( 1234+).
00002404                                  2448  *	5	Unrecognized character in the input string ( 1233j35).
00002404                                  2449  *	6	Empty parenthesis.
00002404                                  2450  *
00002404                                  2451  *---------------------------------------------------------------------------------
00002404  48E7 0080                       2452  errorprt:	movem.l	a0,-(sp)	; save the registers
00002408  7000                            2453  		move.l	#0,d0		; clear d0
0000240A  41F9 0000842A                   2454  		lea	error,a0	; get error address
00002410  3010                            2455  		move.w	(a0),d0		; get the error flags
00002412  B07C 0000                       2456  		cmp.w	#0,d0		; test if there are no errors..
00002416  6700 0080                       2457  		beq	errorext	;   if not, leave
0000241A                                  2458  
0000241A  41F9 00008478                   2459  		lea	yesError,a0	; load the error message
00002420  4EB8 1D98                       2460  		jsr	prt_str		; print the error message header
00002424  E240                            2461  		asr.w	#1,d0		; test the #0 bit, for errorA
00002426  6400 000C                       2462  		bcc	tsterrB		; if C==0, then not error A
0000242A  41F9 000084D4                   2463  		lea	errorA,a0	; set error A address
00002430  4EB8 1D98                       2464  		jsr	prt_str		; print the string
00002434  E240                            2465  tsterrB:	asr.w	#1,d0		; test bit #1
00002436  6400 000C                       2466  		bcc	tsterrC		; if not set, then skip
0000243A  41F9 00008511                   2467  		lea	errorB,a0
00002440  4EB8 1D98                       2468  		jsr	prt_str
00002444  E240                            2469  tsterrC:	asr.w	#1,d0
00002446  6400 000C                       2470  		bcc	tsterrD
0000244A  41F9 0000853F                   2471  		lea	errorC,a0
00002450  4EB8 1D98                       2472  		jsr	prt_str
00002454  E240                            2473  tsterrD:	asr.w	#1,d0
00002456  6400 000C                       2474  		bcc	tsterrE
0000245A  41F9 0000856F                   2475  		lea	errorD,a0
00002460  4EB8 1D98                       2476  		jsr	prt_str
00002464  E240                            2477  tsterrE:	asr.w	#1,d0
00002466  6400 000C                       2478  		bcc	tsterrF
0000246A  41F9 0000859E                   2479  		lea	errorE,a0
00002470  4EB8 1D98                       2480  		jsr	prt_str
00002474  E240                            2481  tsterrF:	asr.w	#1,d0
00002476  6400 000C                       2482  		bcc	tsterrG
0000247A  41F9 000085C2                   2483  		lea	errorF,a0
00002480  4EB8 1D98                       2484  		jsr	prt_str
00002484  E240                            2485  tsterrG:	asr.w	#1,d0
00002486  6400 001A                       2486  		bcc	errorlve
0000248A  41F9 000085EE                   2487  		lea	errorG,a0
00002490  4EB8 1D98                       2488  		jsr	prt_str
00002494  6000 000C                       2489  		bra	errorlve
00002498                                  2490  
00002498  41F9 000084AD                   2491  errorext:	lea	noError,a0	; load no error message
0000249E  4EB8 1D98                       2492  		jsr	prt_str		; print the no error message
000024A2  41F9 0000842A                   2493  errorlve:	lea	error,a0	; get ready to restore the return value
000024A8  3010                            2494  		move.w	(a0),d0		; set the return value
000024AA  4CDF 0100                       2495  		movem.l	(sp)+,a0	; restore registers
000024AE  4E75                            2496  		rts
000024B0                                  2497  *---------------------------------------------------------------------------------
000024B0                                  2498  *	in2pos - infix to postfix notation translator
000024B0                                  2499  *	Input:	The expression is stored in location 'input'.
000024B0                                  2500  *	Output: If there are any errors, they are printed to the terminal. 
000024B0                                  2501  *		Otherwise, the expression in postfix form is stored in location 'expres'.
000024B0                                  2502  *
000024B0                                  2503  *	Variables:	d0 - the current character.
000024B0                                  2504  *			d1 - the current type of character, see the preprocessor header
000024B0                                  2505  *			d2 - the character on top of the stack.
000024B0                                  2506  *			d3 - temporary variable for popping the stack
000024B0                                  2507  *			d4 - the type of the last character read in
000024B0                                  2508  *
000024B0                                  2509  *			a0 - the address of 'output', as in preprocessor output.
000024B0                                  2510  *			a1 - the address of 'expres'.
000024B0                                  2511  *			a2 - the temporary stack used to translate
000024B0                                  2512  *	
000024B0                                  2513  *---------------------------------------------------------------------------------
000024B0  48E7 F0E0                       2514  in2pos:		movem.l	d0/d1/d2/d3/a0/a1/a2,-(sp)	; save the registers.
000024B4                                  2515  
000024B4  4EB8 2246                       2516  		jsr	preproc		; jump to the preprocessor
000024B8  4EB8 1DB0                       2517  		jsr	newline		
000024BC  4EB8 2404                       2518  		jsr 	errorprt	; print any errors (if any)
000024C0  4EB8 1DB0                       2519  		jsr	newline
000024C4                                  2520  
000024C4                                  2521  	* The following lines were used for debugging----------------------
000024C4                                  2522  	* We check if the user wants to see them though
000024C4  41F9 000086BE                   2523  		lea	see_pre,a0	; get the variable address
000024CA  1410                            2524  		move.b	(a0),d2		; get the variable
000024CC  B43C 0000                       2525  		cmp.b	#0,d2		; test if not to show preproc
000024D0  6700 001E                       2526  		beq	preskip
000024D4                                  2527  
000024D4  41F9 0000862E                   2528  		lea	head2,a0
000024DA  4EB8 1D98                       2529  		jsr	prt_str		; print the header
000024DE  41F9 0000839D                   2530  		lea	output,a0	; load the preprocessor output
000024E4  4EB8 1D98                       2531  		jsr	prt_str		; print it
000024E8  4EB8 1DB0                       2532  		jsr	newline		; print a newline
000024EC  4EB8 1DB0                       2533  		jsr	newline
000024F0                                  2534  	* End of debuging lines---------------------------------------------
000024F0                                  2535  
000024F0  B07C 0000                       2536  preskip:	cmp.w	#0,d0		; test the return value from errorprt, 
000024F4  6600 00FA                       2537  		bne	te_done		; if error(s) than we can not continue		
000024F8  41F9 0000839D                   2538  		lea	output,a0	; get the address of the the string
000024FE  43F9 000083D9                   2539  		lea	expres,a1	; get the address of where to store the translation.
00002504  45F9 0000862D                   2540  		lea	stack,a2	; get the address of the stack.
0000250A                                  2541  
0000250A  1412                            2542  translp:	move.b	(a2),d2		; set the character from top of the stack
0000250C                                  2543  
0000250C  1018                            2544  		move.b	(a0)+,d0	; the the next character
0000250E  B03C 0030                       2545  		cmp.b	#$30,d0		; test if less than '0'
00002512  6D00 000E                       2546  		blt	trans2
00002516  B03C 0039                       2547  		cmp.b	#$39,d0		; test if greater than '9'
0000251A  6E00 0006                       2548  		bgt	trans2
0000251E  6000 00A0                       2549  		bra	transdgt	; otherwise, it's a digit
00002522                                  2550  
00002522  B03C 0028                       2551  trans2:		cmp.b	#'(',d0		; check for highest priority
00002526  6700 0040                       2552  		beq	tr_lft		; if so, jump
0000252A  B03C 0029                       2553  		cmp.b	#')',d0		; test if a left paren
0000252E  6700 003C                       2554  		beq	tr_rite		;   if so branch
00002532  B03C 005E                       2555  		cmp.b	#'^',d0		; test if a negation sign
00002536  6700 004C                       2556  		beq	tr_neg		
0000253A  B03C 002A                       2557  		cmp.b	#'*',d0		; test if it's a '*'
0000253E  6700 0052                       2558  		beq	tr_pri2		
00002542  B03C 002F                       2559  		cmp.b	#'/',d0		; test if it's a '/'
00002546  6700 004A                       2560  		beq	tr_pri2		
0000254A  B03C 002B                       2561  		cmp.b	#'+',d0		; test if a plus sign
0000254E  6700 005C                       2562  		beq	tr_pri1
00002552  B03C 002D                       2563  		cmp.b	#'-',d0		; test if a minus sign
00002556  6700 0054                       2564  		beq	tr_pri1		
0000255A                                  2565  	
0000255A  B03C 0000                       2566  		cmp.b	#0,d0		; test if it's a NULL
0000255E  6000 007C                       2567  		bra	t_end	;   if so, finished
00002562                                  2568  	* testing for a minus sign was already done,... anything else should be an error
00002562                                  2569  	* skip over it for now though
00002562  60A6                            2570  		bra	translp		; repeat, skip over an unrecognized characters
00002564                                  2571  tr_lwr:	* this is for when the symbol on the stack is lower than that of the current one
00002564  1500                            2572  		move.b	d0,-(a2)	; push the current onto the stack
00002566  60A2                            2573  		bra	translp
00002568                                  2574  
00002568                                  2575  tr_lft:	* a left parenthesis, highest priority, so always pop into the stack
00002568  1500                            2576  		move.b	d0,-(a2)	; move onto the stack
0000256A  609E                            2577  		bra	translp
0000256C                                  2578  
0000256C                                  2579  tr_rite: * a right parenthesis, pop stack until a left one is reached
0000256C  141A                            2580  		move.b	(a2)+,d2	; get the first char from the stack
0000256E  B43C 0028                       2581  		cmp.b	#'(',d2		; check the top of the stack
00002572  6796                            2582  		beq	translp		; if a '(', then we are done here
00002574  B43C 0000                       2583  		cmp.b	#0,d2		; test if a NULL, it's an error check
00002578  6700 0062                       2584  		beq	t_end		;    if so, we are done
0000257C                                  2585  
0000257C  12C2                            2586  		move.b	d2,(a1)+	; otherwise, it's an operator that
0000257E  12FC 0020                       2587  		move.b	#$20,(a1)+	;   needs moved to the output, with a space
00002582  60E8                            2588  		bra	tr_rite		; loop again and test if we are done
00002584                                  2589  
00002584                                  2590  tr_neg:	* unary negation
00002584  B43C 005E                       2591  		cmp.b	#'^',d2		; check if the stack is a ^
00002588  66DA                            2592  		bne	tr_lwr		; if not, than it is lower pri, so store on stack
0000258A  12DA                            2593  		move.b	(a2)+,(a1)+	; pop the stack to the output
0000258C  12FC 0020                       2594  		move.b	#$20,(a1)+	;  add in a space
00002590  60D2                            2595  		bra	tr_lwr		; now we can push the ^ onto the stack
00002592                                  2596  
00002592                                  2597  tr_pri2: * multiply and divide
00002592  0C12 002D                       2598  		cmp.b	#'-',(a2)	; test if a - is on top
00002596  67CC                            2599  		beq	tr_lwr		; it's of lower priority
00002598  0C12 002B                       2600  		cmp.b	#'+',(a2)	; test if + is on top
0000259C  67C6                            2601  		beq	tr_lwr		; it's of lower priority
0000259E  0C12 0000                       2602  		cmp.b	#0,(a2)		; test if nothing on stack
000025A2  67C0                            2603  		beq	tr_lwr		;   if nothing, the definitily lower
000025A4                                  2604  	* otherwise, it means it's of higher or equal priority, so pop
000025A4  12DA                            2605  		move.b	(a2)+,(a1)+	; pop to the output
000025A6  12FC 0020                       2606  		move.b	#$20,(a1)+	; add in a space
000025AA  60E6                            2607  		bra	tr_pri2		; keep going until lower priority
000025AC                                  2608  
000025AC                                  2609  tr_pri1: * add and subract
000025AC                                  2610  	* pop until either a '(' or a NULL if found on the stack
000025AC                                  2611  	*  reason - pop as long as the top is of equal or higher priority
000025AC                                  2612  	*     everything except the '(' has a equal or higher priority.
000025AC  0C12 0028                       2613  		cmp.b	#'(',(a2)	; test the top
000025B0  67B2                            2614  		beq	tr_lwr		;   if a '(', then it is of lower pri
000025B2  0C12 0000                       2615  		cmp.b	#0,(a2)		; test if nothing on the stack
000025B6  67AC                            2616  		beq	tr_lwr		; if not, lower priority
000025B8  12DA                            2617  		move.b	(a2)+,(a1)+	; otherwise, we need to pop the operators
000025BA  12FC 0020                       2618  		move.b	#$20,(a1)+	; add in a space
000025BE  60EC                            2619  		bra	tr_pri1		; keep on branching
000025C0                                  2620  
000025C0  12C0                            2621  transdgt:	move.b	d0,(a1)+	; move to the output
000025C2  4EB8 21DE                       2622  		jsr	charread	; get the next character
000025C6  B23C 0001                       2623  		cmp.b	#1,d1		; test if still a digit
000025CA  6600 0004                       2624  		bne	trdgtend	; if not, finish operand.
000025CE  60F0                            2625  		bra	transdgt	; it it is another digit, keep looping
000025D0  12FC 0020                       2626  trdgtend:	move.b	#$20,(a1)+	; send a space to the expression string
000025D4  183C 0001                       2627  		move.b	#1,d4		; set previous type
000025D8  6000 FF48                       2628  		bra	trans2		; continue on..		
000025DC                                  2629  
000025DC  0C12 0000                       2630  t_end:		cmp.b	#0,(a2)		; test the top of the stack
000025E0  6700 000A                       2631  		beq	t_leave
000025E4  12DA                            2632  		move.b	(a2)+,(a1)+	; send extra operators to output
000025E6  12FC 0020                       2633  		move.b	#$20,(a1)+	; add in a space
000025EA  60F0                            2634  		bra	t_end		; keep on looping till done
000025EC                                  2635  
000025EC  12BC 0000                       2636  t_leave:	move.b	#0,(a1)		; enter in a NULL
000025F0  4CDF 070F                       2637  te_done:	movem.l	(sp)+,d0/d1/d2/d3/a0/a1/a2	restore the registers
000025F4  4E75                            2638  		rts			; return from in2pos
000025F6                                  2639  
000025F6                                  2640  *---------------------------------------------------------------------------------
000025F6                                  2641  *	read_in: 	sub routine to read in expressions from the keyboard.
000025F6                                  2642  *	Input:	a0 - The address to store the character string.
000025F6                                  2643  *		maxin:	A byte size integer containing the maximun number of
000025F6                                  2644  *			characters that can be stored in the string.
000025F6                                  2645  *	Output: a0 - The string in ASCII form.  It is read until either a <RETURN>
000025F6                                  2646  *		     is pressed or the maximum number of characters is reached.
000025F6                                  2647  *	Variables:
000025F6                                  2648  *		a0 - the address of the string stored in memory
000025F6                                  2649  *		d0 - used to show the characters onto the screen.
000025F6                                  2650  *		d1 - the maximum number of characters that can be read in
000025F6                                  2651  *		d2 - the number of characters read in so far.
000025F6                                  2652  *	Note:	I made it so that the backspace button deletes the previous character
000025F6                                  2653  *---------------------------------------------------------------------------------
000025F6  48E7 E0C0                       2654  read_in:	movem.l	d0/d1/d2/a0/a1,-(sp)	; store the registers to the stack.
000025FA  43F9 00008429                   2655  		lea	maxin,a1		; get the address of maxin
00002600  1211                            2656  		move.b	(a1),d1 		; set the max num of char
00002602  343C 0000                       2657  		move.w	#0,d2			; set the number of char read in to zero
00002606                                  2658  
00002606  4E41                            2659  rd_loop:	trap	#1			; check keyboard
00002608  B03C 0000                       2660  		cmp.b	#0,d0			; check if key pressed
0000260C  67F8                            2661  		beq	rd_loop			; if not (do==0), loop
0000260E                                  2662  
0000260E  4E42                            2663  		trap	#2			; get the character
00002610  B03C 000D                       2664  		cmp.b	#$0d,d0			; check if enter was pressed
00002614  6700 004E                       2665  		beq	rd_done			; if so, then all done
00002618                                  2666  
00002618  B03C 0008                       2667  		cmp.b	#$08,d0			; check if backspace
0000261C  6600 0028                       2668  		bne	rd_other		; if not, go process the character
00002620                                  2669  		
00002620  B47C 0000                       2670  		cmp.w	#0,d2			; make sure we have read some characters in
00002624  6E00 000A                       2671  		bgt	rd_backsp		; if there are some characters, the process the backspace
00002628  103C 0020                       2672  		move.b	#$20,d0			; if not, we need to account for the backspace
0000262C  4E43                            2673  		trap	#3			; moves the cursor back into position
0000262E  60D6                            2674  		bra	rd_loop			; now continue on to next char
00002630                                  2675  
00002630  5388                            2676  rd_backsp:	sub.l	#1,a0			; go back one space
00002632  10BC 0000                       2677  		move.b	#0,(a0)			; clear the string of the old character
00002636  103C 0020                       2678  		move.b	#$20,d0			; get a space ready...
0000263A  4E43                            2679  		trap	#3			;    and print it
0000263C  103C 0008                       2680  		move.b	#$08,d0			; now move back to where the cursor should be..
00002640  4E43                            2681  		trap	#3			;    and print it to move.
00002642  5302                            2682  		sub.b	#1,d2			; we can now take one more character
00002644  60C0                            2683  		bra	rd_loop			; now go get some more characters.
00002646                                  2684  
00002646  10C0                            2685  rd_other:	move.b	d0,(a0)+		; move the character into the string
00002648                                  2686  
00002648  5202                            2687  rd_check:	add.b	#1,d2			; increment number of characters read in
0000264A  B401                            2688  		cmp.b	d1,d2			; test if maximum
0000264C  66B8                            2689  		bne	rd_loop			; if not, we can take more characters
0000264E  10BC 0000                       2690  		move.b	#0,(a0)			; else, too many characters, end the string
00002652  4EB8 1DB0                       2691  		jsr	newline
00002656  41F9 0000842E                   2692  		lea	warning,a0		; warn the user that they have reached the maximum
0000265C  4EB8 1D98                       2693  		jsr	prt_str			;  number of characters in the input string
00002660  6000 0006                       2694  		bra	rddone2
00002664                                  2695  
00002664  10BC 0000                       2696  rd_done:	move.b	#0,(a0)			; enter a NULL into the string
00002668  4CDF 0307                       2697  rddone2:	movem.l (sp)+,d0/d1/d2/a0/a1	; restore registers
0000266C  4E75                            2698  		rts				; return 
0000266E                                  2699  
0000266E                                  2700  *---------------------------------------------------------------------------------
0000266E                                  2701  * Subrouting to divide two 32-bit numbers.
0000266E                                  2702  *	Input:	d1 - the dividend, I think 	(numerator)
0000266E                                  2703  *		d2 - the divisor (?)		(denominator)
0000266E                                  2704  *	Output: d1 - The answer ( d1/d2 )
0000266E                                  2705  *		d2 - If the denominator is zero, this is set to non-zero.
0000266E                                  2706  *		     Zero on valid operation.
0000266E                                  2707  *	Variables:
0000266E                                  2708  *		d1/d2 - numerator/denominator
0000266E                                  2709  *		d3 - temp register used to shift into
0000266E                                  2710  *		d4 - the result so far
0000266E                                  2711  *		d5 - 31 zeros, and one bit set.  Used for setting d4
0000266E                                  2712  *---------------------------------------------------------------------------------
0000266E  48E7 1C00                       2713  div32:		movem.l	d3/d4/d5,-(sp)	; save registers
00002672  4285                            2714  		clr.l	d5		; clear d5
00002674  08C5 001F                       2715  		bset	#31,d5		;  and then set the bit
00002678  4284                            2716  		clr.l	d4		; clear the answer
0000267A  4283                            2717  		clr.l	d3		; clear the temp register
0000267C                                  2718  
0000267C  B4BC 00000000                   2719  		cmp.l	#0,d2		; test if divide by zero
00002682  6600 000C                       2720  		bne	div32Loop	; if not, continue
00002686  7200                            2721  		move.l	#0,d1
00002688  143C 0010                       2722  		move.b	#16,d2		; set the error code
0000268C  6000 0028                       2723  		bra	div_leave	; and leave the subroutine
00002690                                  2724  
00002690  E38B                            2725  div32Loop:	lsl.l	#1,d3		; shift left part of dividend
00002692  E389                            2726  		lsl.l	#1,d1		; shift right part
00002694  6400 0008                       2727  		bcc	divSkip
00002698  86BC 00000001                   2728  		or.l	#1,d3		; set the first bit of d3
0000269E  B682                            2729  divSkip:	cmp.l	d2,d3		; check if we can divide this number
000026A0  6C00 000A                       2730  		bge	div_Yes		; if d3 greater than d2, we can subtract
000026A4  E28D                            2731  set_loop:	lsr.l	#1,d5
000026A6  6500 000A                       2732  		bcs	div_done	; if carry bit is set, then we are all done
000026AA  60E4                            2733  		bra	div32Loop
000026AC                                  2734  
000026AC  9682                            2735  div_Yes:	sub.l	d2,d3		; d3 = d3-d2
000026AE  8885                            2736  		or.l	d5,d4		; set the bit in the answer
000026B0  60F2                            2737  		bra	set_loop	; go do the regular stuff
000026B2                                  2738  
000026B2  2204                            2739  div_done	move.l	d4,d1
000026B4  7400                            2740  		move.l	#0,d2		
000026B6                                  2741  
000026B6  4CDF 0038                       2742  div_leave:	movem.l	(sp)+,d3/d4/d5	; restore registers
000026BA  4E75                            2743  		rts
000026BC                                  2744  
000026BC                                  2745  ******************************************************************
000026BC                                  2746  *  A 32bit unsigned multiply subroutine
000026BC                                  2747  *
000026BC                                  2748  *  Following section of code multiply d1 (32bit) by d2 (32bit) and
000026BC                                  2749  *  produce product (64bit) in d2 (msb) and d1 (lsb), unsigned.
000026BC                                  2750  *  
000026BC                                  2751  *  Divide and conqure algorithm, using 16bit unsigned multiply
000026BC                                  2752  *  instruction of MC68000.
000026BC                                  2753  *
000026BC                                  2754  ******************************************************************
000026BC  48E7 1C00                       2755  mult32:		movem.l	d3/d4/d5,-(sp)	;A 32bit multiply subroutine.
000026C0  2A01                            2756  		move.l	d1,d5		;Copy multiplier, multiplicand
000026C2  2801                            2757  		move.l	d1,d4		;  distribute them over
000026C4  4844                            2758  		swap	d4		;  multiple registers
000026C6  2602                            2759  		move.l	d2,d3		;  to generate partial
000026C8  4842                            2760  		swap	d2		;  products.
000026CA                                  2761  
000026CA  C2C3                            2762  		mulu	d3,d1		;Generate 4 partial products.
000026CC  CAC2                            2763  		mulu	d2,d5
000026CE  C6C4                            2764  		mulu	d4,d3
000026D0  C4C4                            2765  		mulu	d4,d2
000026D2                                  2766  
000026D2  2805                            2767  		move.l	d5,d4		;Split d5 into d5 and d4,
000026D4  4845                            2768  		swap	d5		;  add them to d1 and d2
000026D6  4245                            2769  		clr.w	d5
000026D8  4244                            2770  		clr.w	d4
000026DA  4844                            2771  		swap	d4
000026DC  D285                            2772  		add.l	d5,d1
000026DE  D584                            2773  		addx.l	d4,d2
000026E0                                  2774  
000026E0  2803                            2775  		move.l	d3,d4		;Split d3 into d3 and d4,
000026E2  4843                            2776  		swap	d3		;  add them to d1 and d2
000026E4  4243                            2777  		clr.w	d3
000026E6  4244                            2778  		clr.w	d4
000026E8  4844                            2779  		swap	d4
000026EA  D283                            2780  		add.l	d3,d1
000026EC  D584                            2781  		addx.l	d4,d2
000026EE  4CDF 0038                       2782  		movem.l	(sp)+,d3/d4/d5	;All done
000026F2  4E75                            2783  		rts
000026F4                                  2784  
000026F4                                  2785  *---------------------------------------------------------------------------------
000026F4                                  2786  		end			; end of file

No errors detected
No warnings generated
